"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["85460"],{1190:function(r,e,a){a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>h,metadata:()=>n,toc:()=>l});var n=a(33595),t=a(85893),s=a(50065);let h={tags:["win32"]},i="Hash Data using Win32 API through a CHashDataProvider class",o={authorsImageUrls:[]},l=[];function d(r){let e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"Cryptography is the use of codes to convert data so that only a specific recipient will be able to read it. Microsoft provide win32 API to Hash Data/string. The class CHashDataProvider developed to provides simple function HashData(ALG_ID algorithmID, LPCTSTR plainText, LPTSTR hashedText); which takes algorithmID and inputText to convert plainText to hashedText"}),"\n",(0,t.jsx)(e.p,{children:"ALG_ID algorithmID - Algorithm ID to be used LPCTSTR plainText - plainText that to be converted to hashedText LPTSTR hashedText - Hashed Test using the input algorithmID."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"CHashDataProvider Code"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"HashDataProvider.h"})})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"#include <wincrypt.h>;\r\n#define BUFFER_SIZE 256\r\n\r\nclass CHashDataProvider\r\n{\r\npublic:\r\n    CHashDataProvider(void);\r\n    ~CHashDataProvider(void);\r\n\r\nprivate:\r\n    // Handle to a cryptographic service provider (CSP)\r\n    HCRYPTPROV  m_hProv;\r\n\r\n    // Handle to the hash object needed to create a hash.\r\n    HCRYPTHASH  m_hHash;\r\n\r\n    // Pointer to the hash.\r\n    PBYTE       m_pbHash;\r\n\r\nprivate:\r\n    void FreeResources();\r\n    void InitializeData();\r\n    LPTSTR FormatData(PBYTE pbHash, DWORD dwDataLen, LPTSTR hashedText);\r\n\r\npublic:\r\n    bool HashData(ALG_ID  algorithmID, LPCTSTR plainText, LPTSTR  hashedText);\r\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"HashDataProvider.cpp"})})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include "HashDataProvider.h"\r\n\r\nCHashDataProvider::CHashDataProvider(void)\r\n{\r\n    InitializeData();\r\n}\r\n\r\nCHashDataProvider::~CHashDataProvider(void)\r\n{\r\n}\r\n\r\n//\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\r\n// des:    Hashes data based on the ALG_ID\r\n// return: Hashing of the text is sucessful or not\r\n//\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\r\nbool\r\nCHashDataProvider::HashData(ALG_ID  algorithmID, // in | Algorithm ID (Sha1 or MD5 )\r\n                            LPCTSTR plainText,   // in | Original string to be hashed\r\n                            LPTSTR  hashedText)    //out | string to store hashed text\r\n{\r\n    InitializeData();\r\n\r\n    bool        rc          = true;      // Default is success\r\n    DWORD       dwDataLen   = 0;         // Length, in bytes, of the hash.\r\n\r\n    //--------------------------------------------------------------------\r\n    // Acquire a handle to the default RSA cryptographic service provider.\r\n    if (!CryptAcquireContext(\r\n        &amp;m_hProv,                 // handle of the CSP\r\n        NULL,                     // key container name\r\n        NULL,                     // CSP name\r\n        PROV_RSA_FULL,            // provider type\r\n        CRYPT_VERIFYCONTEXT))     // no key access is requested\r\n    {\r\n        AfxMessageBox("Error in AcquireContext 0x%08x n", GetLastError());\r\n        rc = false;\r\n        FreeResources();\r\n    }\r\n\r\n    if (!CryptCreateHash(\r\n        m_hProv,                  // handle of the CSP\r\n        algorithmID,              // hash algorithm to use\r\n        0,                        // hash key\r\n        0,                        // reserved\r\n        &amp;m_hHash))                // address of hash object handle\r\n    {\r\n        AfxMessageBox("Error in CryptCreateHash 0x%08x n", GetLastError());\r\n        rc = false;\r\n        FreeResources();\r\n    }\r\n\r\n    if (!CryptHashData(\r\n        m_hHash,                  // handle of the hash object\r\n        (const BYTE *) plainText, // text to be hash\r\n        _tcslen(plainText)*sizeof(TCHAR), // number of bytes of data\r\n        0))                       // flags\r\n    {\r\n        AfxMessageBox("Error in CryptHashData 0x%08x n", GetLastError());\r\n        rc = false;\r\n        FreeResources();\r\n    }\r\n\r\n    if (!CryptGetHashParam(\r\n        m_hHash,                 // handle of the HMAC hash object\r\n        HP_HASHVAL,              // query on the hash value\r\n        NULL,                    // pointer to the HMAC hash value\r\n        &amp;dwDataLen,              // length,in bytes, of the hash\r\n        0))\r\n    {\r\n        AfxMessageBox("Error in CryptGetHashParam 0x%08x n", GetLastError());\r\n        rc = false;\r\n        FreeResources();\r\n    }\r\n\r\n    m_pbHash = (BYTE\\*)malloc(dwDataLen);\r\n    if(NULL == m_pbHash)\r\n    {\r\n       AfxMessageBox("unable to allocate memoryn");\r\n       rc = false;\r\n       FreeResources();\r\n    }\r\n\r\n    if (!CryptGetHashParam(\r\n        m_hHash,                   // handle of the HMAC hash object\r\n        HP_HASHVAL,                // query on the hash value\r\n        m_pbHash,                  // pointer to the HMAC hash value\r\n        &amp;dwDataLen,                // length,in bytes, of the hash\r\n        0))\r\n    {\r\n        AfxMessageBox("Error in CryptGetHashParam 0x%08x n", GetLastError());\r\n        rc = false;\r\n        FreeResources();\r\n    }\r\n\r\n    hashedText = FormatData(m_pbHash, dwDataLen, hashedText);\r\n\r\n    FreeResources();\r\n\r\n    return rc;\r\n}\r\n\r\n//Helper functions\r\nvoid CHashDataProvider::FreeResources()\r\n{\r\n    if(m_hHash)\r\n        CryptDestroyHash(m_hHash);\r\n    if(m_hProv)\r\n        CryptReleaseContext(m_hProv, 0);\r\n    if(m_pbHash)\r\n       free(m_pbHash);\r\n}\r\n\r\nvoid CHashDataProvider::InitializeData()\r\n{\r\n    m_hProv = NULL;\r\n    m_hHash = NULL;\r\n    m_pbHash = NULL;\r\n}\r\n\r\nLPTSTR CHashDataProvider::FormatData(PBYTE pbHash, DWORD dwDataLen, LPTSTR hashedText)\r\n{\r\n    TCHAR rstData[BUFFER_SIZE]= {0}; // Buffer to receive hashed result\r\n    TCHAR tmpBuffer[3] = {0};\r\n    for (DWORD i = 0 ; i &lt; dwDataLen ; i++)\r\n    {\r\n        tmpBuffer[0] = 0;\r\n        tmpBuffer[1] = 0;\r\n        tmpBuffer[2] = 0;\r\n        _stprintf_s(tmpBuffer, _T("%2.2x"), pbHash\\[i\\]);\r\n        _tcscat_s(rstData, tmpBuffer);\r\n    }\r\n    _tcscpy(hashedText, rstData);\r\n\r\n    return hashedText;\r\n}\n'})})]})}function c(r={}){let{wrapper:e}={...(0,s.a)(),...r.components};return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}},33595:function(r){r.exports=JSON.parse('{"permalink":"/blog/2012/03/15/win32-api-through-a-chashdataprovider-class","source":"@site/blog/2012-03-15-win32-api-through-a-chashdataprovider-class.md","title":"Hash Data using Win32 API through a CHashDataProvider class","description":"Cryptography is the use of codes to convert data so that only a specific recipient will be able to read it. Microsoft provide win32 API to Hash Data/string. The class CHashDataProvider developed to provides simple function HashData(ALG_ID algorithmID, LPCTSTR plainText, LPTSTR hashedText); which takes algorithmID and inputText to convert plainText to hashedText","date":"2012-03-15T00:00:00.000Z","tags":[{"inline":true,"label":"win32","permalink":"/blog/tags/win-32"}],"readingTime":2.66,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["win32"]},"unlisted":false,"prevItem":{"title":"Check whether a given file exists in the given path","permalink":"/blog/2012/03/15/whether-a-given-file-exists-in-the-givenpath"},"nextItem":{"title":"Creating an SDI/MDI application that is initially maximized","permalink":"/blog/2012/03/14/sdimdi-application-that-is-initially-maximized"}}')},50065:function(r,e,a){a.d(e,{Z:()=>i,a:()=>h});var n=a(67294);let t={},s=n.createContext(t);function h(r){let e=n.useContext(s);return n.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function i(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:h(r.components),n.createElement(s.Provider,{value:e},r.children)}}}]);