"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[73606],{27904:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var t=r(85893),i=r(11151);const a={tags:["Data Structures","C++"]},s="Simple Queue program in C++",o={permalink:"/blog/2012/04/02/queue",source:"@site/blog/2012-04-02-queue.md",title:"Simple Queue program in C++",description:"Definition:",date:"2012-04-02T00:00:00.000Z",formattedDate:"April 2, 2012",tags:[{label:"Data Structures",permalink:"/blog/tags/data-structures"},{label:"C++",permalink:"/blog/tags/c"}],readingTime:.93,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["Data Structures","C++"]},unlisted:!1,prevItem:{title:"'Builder' Design Pattern using simple program",permalink:"/blog/2012/04/03/builderdesignpatter"},nextItem:{title:"Simple Stack Program in C++",permalink:"/blog/2012/04/02/stack"}},l={authorsImageUrls:[]},u=[];function d(n){const e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Definition:"})}),"\n",(0,t.jsxs)(e.p,{children:["A Queue\xa0is a data structure in which addition of new element takes place at the end called ",(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"rear"})})," of Queue and\xa0deletion of existing element takes place at the other end called ",(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"front"})})," of Queue\xa0."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Principle:"})}),"\n",(0,t.jsxs)(e.p,{children:["Queue\xa0works on the ",(0,t.jsx)(e.strong,{children:"FIFO"})," \u2013 ",(0,t.jsx)(e.strong,{children:"F"}),"irst\xa0",(0,t.jsx)(e.strong,{children:"I"}),"n ",(0,t.jsx)(e.strong,{children:"F"}),"irst ",(0,t.jsx)(e.strong,{children:"O"}),"ut principle"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include "stdafx.h"\r\n#include "iostream"\r\nusing namespace std;\r\n\r\n#define MAX 10\r\n\r\nclass Queue\r\n{\r\nprivate:\r\n       int arr[MAX];\r\n       int front, rear;\r\n\r\npublic:\r\n      Queue()\r\n      {\r\n            front = -1;\r\n            rear  = -1;\r\n\r\n      }\r\n\r\n       void Add(int item)\r\n      {\r\n             if(rear == MAX-1)\r\n            {\r\n                  cout<<endl<< "Queue is full";\r\n                   return;\r\n            }\r\n\r\n            rear++;\r\n            arr[rear] = item;\r\n\r\n             if( front == -1 )\r\n                  front = 0;\r\n      }\r\n\r\n       int Delete()\r\n      {\r\n             if(front == -1)\r\n            {\r\n                  cout<<endl<< "Queue is empty";\r\n                   return NULL;\r\n            }\r\n\r\n        int data = arr[front];\r\n\r\n             if( front == rear)\r\n                  front = rear = -1;\r\n             else\r\n                  front++;\r\n\r\n             return data;\r\n      }\r\n};\r\n\r\nint main()\r\n{\r\n      Queue q;\r\n\r\n      q.Add(1);\r\n      q.Add(2);\r\n      q.Add(3);\r\n\r\n       int i = q.Delete();\r\n      cout<<endl<< "item="" deleted="<<i<<endl;\r\n\r\n      i = q.Delete();\r\n      cout<<endl<< "Item deleted = "<<i<<endl;\r\n\r\n       return 0;\r\n}\r\n\r\n/*\r\nOUTPUT\r\n----------------\r\nItem deleted = 1\r\n\r\nItem deleted = 2\r\n*/\n'})})]})}function c(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},11151:(n,e,r)=>{r.d(e,{Z:()=>o,a:()=>s});var t=r(67294);const i={},a=t.createContext(i);function s(n){const e=t.useContext(a);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);