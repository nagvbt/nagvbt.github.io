"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["62037"],{39784:function(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});var t=r(49138),s=r(85893),o=r(50065);let i={tags:["MFC","C++"]},a='How to avoid Memory\xa0Leaks in C++, VC++"',l={authorsImageUrls:[]},c=[{value:"<strong>1. Introduction</strong>",id:"1-introduction",level:2},{value:"<strong>2. How to Find Memory Leak</strong>",id:"2-how-to-find-memory-leak",level:2},{value:"<strong>3. Memory Leak and How to avoid it</strong>",id:"3-memory-leak-and-how-to-avoid-it",level:2}];function d(e){let n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Contents"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Introduction"}),"\n",(0,s.jsx)(n.li,{children:"How to find memory leak"}),"\n",(0,s.jsx)(n.li,{children:"Memory Leak and how to avoid it"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Updated on : ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"17-Oct-2014"})})]}),"\n",(0,s.jsx)(n.h2,{id:"1-introduction",children:(0,s.jsx)(n.strong,{children:"1. Introduction"})}),"\n",(0,s.jsx)(n.p,{children:"The failure to properly deallocate memory that was previously allocated is known as Memory Leak. The consequences of memory leaks is that the programs that leak large amounts of memory, or leak progressively, may display symptoms ranging from poor (and gradually decreasing) performance to running out of memory completely. Worse, a leaking program may use up so much memory that it causes another program to fail, leaving the user with no clue to where the problem truly lies. In addition, even harmless memory leaks may be symptomatic of other problems."}),"\n",(0,s.jsx)(n.h2,{id:"2-how-to-find-memory-leak",children:(0,s.jsx)(n.strong,{children:"2. How to Find Memory Leak"})}),"\n",(0,s.jsx)(n.p,{children:"Use third-party tools like DevPartner or use the following steps to find the memory leaks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Compile the project in "Debug" Mode.'}),"\n",(0,s.jsxs)(n.li,{children:["Declare the objects ",(0,s.jsx)(n.strong,{children:"CMemoryState msOld, msNew, msDif;"})]}),"\n",(0,s.jsxs)(n.li,{children:["Check the memory state at one point. ",(0,s.jsx)(n.strong,{children:"msOld.Checkpoint();"})," ://code ://code"]}),"\n",(0,s.jsxs)(n.li,{children:["Check the memory state at onother point. ",(0,s.jsx)(n.strong,{children:"msNew.Checkpoint();"})]}),"\n",(0,s.jsxs)(n.li,{children:["See for Difference ",(0,s.jsx)(n.strong,{children:"msDif.Difference( msOld, msNew );"})]}),"\n",(0,s.jsxs)(n.li,{children:["Display the Leaked blocks in Debug window \xa0",(0,s.jsx)(n.strong,{children:"msDif.DumpStatistics();"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-memory-leak-and-how-to-avoid-it",children:(0,s.jsx)(n.strong,{children:"3. Memory Leak and How to avoid it"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"a. Wrong usage of new/delete."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int* intArr; \r\nintArr = new int[500]; \r\ndelete intArr; \n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use\xa0 ",(0,s.jsx)(n.code,{children:"delete[]intArr;"})," instead of delete\xa0intArr as ",(0,s.jsx)(n.code,{children:"delete intArr"})," is equal to deleting ",(0,s.jsx)(n.code,{children:"intArr[0];"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"b. Improper deletion of Array of Pointers"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"introwNo = 3; \r\nintcolsNo = 3; \r\nint *array = new int[rowNo];\r\n\r\nfor(inti=0; i < rowNo; i++) {\r\n   array[i] = new int[i+1]; \r\n}\r\n\r\ndelete[] array; \n"})}),"\n",(0,s.jsx)(n.p,{children:"The cause of memory leak is that the 'array' is an array of pointers, with each of it's elements pointing to a separate memory block, so it is necessary free these blocks before freeing the array that holds the pointers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"for(int i=0; i < rowNo; i++) \r\n{\r\n   delete[] array[i];\r\n} \r\n    \r\ndelete [] array; \n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"c. Resource Handles: GDI Objects- CBrush, CPen, CFont, CBitmap, CPallete, CRgn and respective handles"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"CBrush myBr, *pOldBr; \r\nmyBr.CreateSolidBrush(RGB(0, 255, 0)); \r\npOldBr = pDC->SelectObject(&myBr); \r\npDC->SelectObject(& myBr );\r\npDC->SelectObject(pOldBrush);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For more details Check:",(0,s.jsx)(n.a,{href:"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx"}),(0,s.jsx)(n.a,{href:"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx",children:"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx"})]}),"\n",(0,s.jsx)(n.p,{children:"The DeleteObject method deletes the GDI object by freeing all system storage associated with it. The storage associated with the CGdiObject object is not affected by this call. An application should not call DeleteObject on a CGdiObject object that is currently selected into a device context. Use myBr.DeleteObject(); after finishing using myBr (Cbrush) object\xa0For handles pass handle of the DeleteObject function DeleteObject(hPen);"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"d. String conversions CString to LPTSTR"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'CString sName; \r\nsName= _T("Hello"); \r\nint lenName = sName.GetLength();\r\nLPTSTR lpstrg = sName.GetBuffer(lenName); \r\n\r\nsName.ReleaseBuffer(); \r\nCstring to BSTR CString csStr = "Hello"; \r\nBSTR bStr = csStr.AllocSysString(); \r\n \r\nSysFreeString(bStr); //finished using the BSTR \n'})}),"\n",(0,s.jsx)(n.p,{children:"Use ReleaseBuffer() when ever we create a buffer. Use SysFreeString() when ever we use AllocSysString() which allocates a new string of the type BSTR."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"e. Improper deletion of pointer objects in a CList"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"CList<CMyData, CMyData> ptList;\r\nCList<CMyData, CMyData> ptList; \r\n ptList.RomoveAll(); //Improper deletion of pointer objects in a CArray CArray<CMyData, CMyData> ptArr;\r\n ptArr.RemoveAll(); \n"})}),"\n",(0,s.jsx)(n.p,{children:"Proper deletion of pointer objects in a CList"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"CList<CMyData, CMyData> ptList;\r\nPOSITION pos = ptList.GetHeadPosition();\r\n\r\nwhile(pos!=NULL) { \r\n  delete ptList.GetNext(pos); \r\n  }\r\n\r\nPtList.RomoveAll();\r\n\r\n// Proper deletion of pointer objects in a CArray CArray<CMyData_, CMyData_\\> ptArr; : : int i = 0;\r\n\r\nwhile(i<ptArr.GetSize()) { \r\n  delete ptArr.GetAt(i++); \r\n  }\r\n\r\nptArr.RemoveAll(); \n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"f. Opening and proper closing of file and databases"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"CFile file; \r\nfile.Open(szFilePath, CFile::modeCreate | CFile::modeWrite, 0); \r\nfile.Write(chFile, chFileSize); \r\nfile.Close(); \n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"e. Usage of Static Arrays"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"int Sample[500]; \n"})}),"\n",(0,s.jsx)(n.p,{children:"Never use static arrays if the array is dynamically growing. Instead of using static arrays use CArray or OCArray Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:" CArray<int, int> Sample; \n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},50065:function(e,n,r){r.d(n,{Z:()=>a,a:()=>i});var t=r(67294);let s={},o=t.createContext(s);function i(e){let n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}},49138:function(e){e.exports=JSON.parse('{"permalink":"/blog/2014/10/17/how-to-avoid-memory-leaks-in-c-vc","source":"@site/blog/2014-10-17-how-to-avoid-memory-leaks-in-c-vc.md","title":"How to avoid Memory\xa0Leaks in C++, VC++\\"","description":"Contents","date":"2014-10-17T00:00:00.000Z","tags":[{"inline":true,"label":"MFC","permalink":"/blog/tags/mfc"},{"inline":true,"label":"C++","permalink":"/blog/tags/c"}],"readingTime":3.24,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["MFC","C++"]},"unlisted":false,"prevItem":{"title":"How to make Visual Studio Run Faster","permalink":"/blog/2015/03/10/how-to-make-visual-studio-run-faster"},"nextItem":{"title":"How to Learn Windows Phone 8.1 apps development","permalink":"/blog/2014/06/12/how-learn-windows-phone-8-1-apps-development"}}')}}]);