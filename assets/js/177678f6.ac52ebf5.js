"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[63857],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,m=u["".concat(s,".").concat(d)]||u[d]||h[d]||l;return n?r.createElement(m,o(o({ref:t},p),{},{components:n})):r.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:a,o[1]=i;for(var c=2;c<l;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},23975:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const l={title:"COM Tutorial Step by Step",date:"2011-09-12",categories:["com-dcom-atl"],tags:["com"]},o=void 0,i={permalink:"/blog/2011/09/12/com-tutorial",source:"@site/blog/2011-09-12-com-tutorial.md",title:"COM Tutorial Step by Step",description:"Creating\xa0comMathServLib which is a COM In-Process DLL for implementing an Simple Addition (Add) and\xa0Subtraction (Sub) functions by writing IMath interface . Finally a console application 'comClient' will consumes the\xa0comMathServLib.",date:"2011-09-12T00:00:00.000Z",formattedDate:"September 12, 2011",tags:[{label:"com",permalink:"/blog/tags/com"}],readingTime:8.78,hasTruncateMarker:!1,authors:[],frontMatter:{title:"COM Tutorial Step by Step",date:"2011-09-12",categories:["com-dcom-atl"],tags:["com"]},prevItem:{title:"Why size of an empty C++ class not zero?",permalink:"/blog/2011/09/18/why-size-of-an-empty-c-class-not-zero"},nextItem:{title:"COM Basics",permalink:"/blog/2011/09/11/com-basics"}},s={authorsImageUrls:[]},c=[],p={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Creating\xa0",(0,a.kt)("strong",{parentName:"p"},"comMathServLib")," which is a COM In-Process DLL for implementing an Simple Addition (Add) and\xa0Subtraction (Sub) functions by writing IMath interface . Finally a console application '",(0,a.kt)("strong",{parentName:"p"},"comClient"),"' will consumes the\xa0comMathServLib."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"The below diagram shows how comMathServLib sample organised to work as COM Inproc Server and also tells about internals of CoCreateInstance(...)"))),(0,a.kt)("p",null,"Conventions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"&lt;strong&gt;uuidof(CMathComp) = classID or CLSID\n&lt;/strong&gt;uuidof(IMath) = InterfaceID or IID\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"To get an Interface pointer to IMath call CoCreateInstance(...)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"IMath\\* pIMath;\nHRESULT hr = CoCreateInstance ( &lt;strong&gt;uuidof(CMathComp), NULL, CLSCTX\\_INPROC\\_SERVER,\n&lt;/strong&gt;uuidof(IMath), (void\\*\\*) &amp;amp;pIMath );\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"CoCreateInstance calls CoGetClassObject(...)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"CoGetClassObject( &lt;strong&gt;uuidof(CMathComp), CLSCTX\\_INPROC\\_SERVER, NULL, &lt;/strong&gt;uuidof(IMath),\n(void\\*\\*) &amp;amp;pIMath);\n")),(0,a.kt)("p",null,"CoGetClassObject invokes the COM Service Control Manager, which searches in the Registry using the classID. It finds the associated ComServer DLL, loads it into memory, and calls the DllGetClassObject method of the DLL."),(0,a.kt)("p",null,"3.The DLL contains an object of CMathCompClassFactory. The DllGetClassObject gets the IClassFactory pointer and COM calls CreateInstance(...)"),(0,a.kt)("p",null,"CreateInstance(...) method creates the CMathComp and returns the Pointer to IMath as requested by CoCreateInstance"),(0,a.kt)("p",null,"Steps for creating \xa0",(0,a.kt)("strong",{parentName:"p"},"comMathServLib")," Project "),(0,a.kt)("p",null,"A. Open Visual Studio 2008",(0,a.kt)("br",{parentName:"p"}),"\n","B. Go to File -> New Project : In the new project dialog under 'Visual C++' select Win32 - Right side select the Win32 Project Template and give the project name as 'comMathServLib'",(0,a.kt)("br",{parentName:"p"}),"\n","C. Win32 Application Wizard Dilog pops up",(0,a.kt)("br",{parentName:"p"}),"\n","-","> Click Next",(0,a.kt)("br",{parentName:"p"}),"\n","-",">In Application Setting -> Application type: Select DLL and click Finish"),(0,a.kt)("h1",{id:"steps-for-adding-required-files-and-writing-code"},"Steps for adding required files and writing code"),(0,a.kt)("p",null,"File can be added by Right click on the Project in 'Solution Explorer' -> Add -> New Item..."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Add a Header File ","[","IMath.h","]"," to declare the Interface for our Math Component class ",(0,a.kt)("em",{parentName:"strong"},"CMathComp")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"IMath.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'&lt;h1&gt;include "Unknwn.h"&lt;/h1&gt;\n\ninterface IMath : IUnknown\n{\n//Simple Math Functions\nvirtual int &lt;strong&gt;stdcall Add(int i, int j) = 0;\nvirtual int &lt;/strong&gt;stdcall Sub(int i, int j) = 0;\n};\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"2.\xa0Add a C++ File ","[","MathComp.cpp","]"," to Implement the IMath Interface and also to implement the IUnkown Interface methods")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"MathComp.cpp")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'&lt;h1&gt;include "stdafx.h"&lt;/h1&gt;\n&lt;h1&gt;include "IMath.h"&lt;/h1&gt;\n&lt;h1&gt;include "MathCompGuidDef.h"&lt;/h1&gt;\n\nclass CMathComp : public IMath\n{\n\npublic:\nCMathComp()\n{\nm\\_uRefCount = 0;\ng\\_uDllLockCount++;\n}\n&lt;pre&gt;&lt;code&gt;virtual ~CMathComp()\n{\n    g\\_uDllLockCount--;\n}\n\n// IUnknown methods\nvirtual ULONG \\_\\_stdcall AddRef()\n{\n    m\\_uRefCount = m\\_uRefCount+1;  // Increment this object\'s reference count.\n    return m\\_uRefCount;\n}\n\nvirtual ULONG \\_\\_stdcall Release()\n{\n    ULONG uRet = m\\_uRefCount-1;   // Decrement this object\'s reference count.\n\n    if ( 0 == m\\_uRefCount )       // Releasing last reference?\n    {\n        delete this;\n    }\n\n    return uRet;\n}\n\nvirtual HRESULT \\_\\_stdcall QueryInterface( REFIID riid, void\\*\\* ppv )\n{\n    HRESULT hrRet = S\\_OK;\n\n    // Check that ppv really points to a void\\*.\n    if ( IsBadWritePtr ( ppv, sizeof(void\\*) ))\n    {\n        return E\\_POINTER;\n    }\n\n    // Standard QI initialization - set \\*ppv to NULL.\n    \\*ppv = NULL;\n\n    // If the client is requesting an interface we support, set \\*ppv.\n    if ( InlineIsEqualGUID ( riid, IID\\_IUnknown ))\n    {\n        \\*ppv = (IUnknown\\*) this;\n    }\n    else if ( InlineIsEqualGUID ( riid, \\_\\_uuidof(IMath) ))\n    {\n        \\*ppv = (IMath\\*) this;\n    }\n    else\n    {\n        hrRet = E\\_NOINTERFACE;\n    }\n\n    // If we\'re returning an interface pointer, AddRef() it.\n    if ( S\\_OK == hrRet )\n    {\n        ((IUnknown\\*) \\*ppv)-&amp;gt;AddRef();\n    }\n\n    return hrRet;\n}\n\n//IMath Implementation\nvirtual int \\_\\_stdcall Add(int i, int j)\n{\n    return i+j;\n}\n\nvirtual int \\_\\_stdcall Sub(int i, int j)\n{\n    return i-j;\n}&lt;/code&gt;&lt;/pre&gt;\n\nprotected:\nUINT m\\_uRefCount; // object\'s reference count\n};\n')),(0,a.kt)("p",null,"3","."," Add a Header File ","[","MathCompGuidDef.h","]"," for assigning GUIDS for IMath and CMathComp"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"MathCompGuidDef.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'struct &lt;strong&gt;declspec(uuid("{4024093A-F7C4-4ecf-8E60-B79C5AEAE6E0}")) IMath;\nclass &lt;/strong&gt;declspec(uuid("{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}")) CMathComp;\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"3","."," Add a C++ File ","[","CMathCompClassFactory.h","]"," to Implement the IClassFactory Interface for our Math Component")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"CMathCompClassFactory.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'&lt;h1&gt;include "stdafx.h"&lt;/h1&gt;\n&lt;h1&gt;include "MathComp.cpp"&lt;/h1&gt;\n\nclass CMathCompClassFactory : public IClassFactory\n{\npublic:\nCMathCompClassFactory()\n{\nm\\_uRefCount = 0;\ng\\_uDllLockCount++;\n&lt;pre&gt;&lt;code&gt;}\nvirtual ~CMathCompClassFactory()\n{\n    g\\_uDllLockCount--;\n}\n\n// IUnknown methods\nvirtual ULONG \\_\\_stdcall AddRef()\n{\n    m\\_uRefCount = m\\_uRefCount+1;  // Increment this object\'s reference count.\n    return m\\_uRefCount;\n}\n\nvirtual ULONG \\_\\_stdcall Release()\n{\n    ULONG uRet = m\\_uRefCount-1;   // Decrement this object\'s reference count.\n\n    if ( 0 == m\\_uRefCount )       // Releasing last reference?\n    {\n        delete this;\n    }\n\n    return uRet;\n}\n\nvirtual HRESULT \\_\\_stdcall QueryInterface( REFIID riid, void\\*\\* ppv )\n{\n    HRESULT hrRet = S\\_OK;\n\n    // Check that ppv really points to a void\\*.\n    if ( IsBadWritePtr ( ppv, sizeof(void\\*) ))\n    {\n        return E\\_POINTER;\n    }\n\n    // Standard QI initialization - set \\*ppv to NULL.\n    \\*ppv = NULL;\n\n    // If the client is requesting an interface we support, set \\*ppv.\n    if ( InlineIsEqualGUID ( riid, IID\\_IUnknown ))\n    {\n        \\*ppv = (IUnknown\\*) this;\n    }\n    else if ( InlineIsEqualGUID ( riid, IID\\_IClassFactory ))\n    {\n        \\*ppv = (IClassFactory\\*) this;\n    }\n    else\n    {\n        hrRet = E\\_NOINTERFACE;\n    }\n\n    // If we\'re returning an interface pointer, AddRef() it.\n    if ( S\\_OK == hrRet )\n    {\n        ((IUnknown\\*) \\*ppv)-&amp;gt;AddRef();\n    }\n\n    return hrRet;\n\n}\n\n// IClassFactory&lt;/code&gt;&lt;/pre&gt;\n\nvirtual HRESULT \\_\\_stdcall CreateInstance ( IUnknown\\* pUnkOuter,\nREFIID riid,\nvoid\\*\\* ppv )\n{\nHRESULT hrRet;\n&lt;pre&gt;&lt;code&gt;    // No support aggregation, so pUnkOuter must be NULL.\n    if ( NULL != pUnkOuter )\n    {\n        return CLASS\\_E\\_NOAGGREGATION;\n    }\n\n    // Check that ppv really points to a void\\*.\n    if ( IsBadWritePtr ( ppv, sizeof(void\\*) ))\n    {\n        return E\\_POINTER;\n    }\n\n    \\*ppv = NULL;\n\n    // Create a new COM object!\n    m\\_pMathServ = new CMathComp();\n\n    if ( NULL == m\\_pMathServ )\n    {\n        return E\\_OUTOFMEMORY;\n    }\n\n    // QueryInterface the object for the interface the client is requesting.\n    hrRet = m\\_pMathServ-&amp;gt;QueryInterface ( riid, ppv );\n\n    // If the QI failed, delete the COM object since the client isn\'t able\n    // to use it (the client doesn\'t have any interface pointers on the object)\n    if ( FAILED(hrRet) )\n    {\n        delete m\\_pMathServ;\n    }\n\n    return hrRet;\n}\n\nvirtual HRESULT \\_\\_stdcall LockServer ( BOOL fLock )\n{\n    // Increase/decrease the DLL ref count, according to the fLock param.\n    fLock ? g\\_uDllLockCount++ : g\\_uDllLockCount--;\n    return S\\_OK;\n}&lt;/code&gt;&lt;/pre&gt;\n\nprotected:\nULONG m\\_uRefCount;\nCMathComp\\* m\\_pMathServ;\n};```\n\n**4\\. Add a C++ File \\[Infrastructure.cpp\\] and add the Infrastructure methods to our comMathServLib In-Process COM Component**\n\n```c\n&lt;h1&gt;include "stdafx.h"&lt;/h1&gt;\n&lt;h1&gt;include "MathCompGuidDef.h"&lt;/h1&gt;\n&lt;h1&gt;include "MathCompClassFactory.cpp"&lt;/h1&gt;\n\nHINSTANCE g\\_hinstThisDll = NULL; // DLL\'s module handle\nUINT g\\_uDllLockCount = 0; // # of COM objects in existence\n\n// DllMain() is our DLL\'s entry point. Windows calls this when a process or thread\n// loads and unloads the DLL.\nBOOL APIENTRY DllMain ( HINSTANCE hModule,\nDWORD ul\\_reason\\_for\\_call,\nLPVOID lpReserved )\n{\nswitch ( ul\\_reason\\_for\\_call )\n{\ncase DLL\\_PROCESS\\_ATTACH:\n{\ng\\_hinstThisDll = hModule;\n&lt;pre&gt;&lt;code&gt;        // Calling DisableThreadLibraryCalls() prevents DllMain() from\n        // getting called for every thread that attaches/detaches from DLL\n        DisableThreadLibraryCalls ( hModule );\n    }\n    break;\n\ncase DLL\\_PROCESS\\_DETACH:\n    {\n    }\n    break;\n}\n\nreturn TRUE;&lt;/code&gt;&lt;/pre&gt;\n\n}\n\n// DllGetClassObject() is called when COM needs to get a class factory.\nSTDAPI DllGetClassObject ( REFCLSID rclsid, REFIID riid, void\\*&lt;em&gt; ppv )\n{\nHRESULT hrRet;\nCMathCompClassFactory&lt;/em&gt; pFactory;\n&lt;pre&gt;&lt;code&gt;// Check that the client is asking for the CSimpleMsgBoxImpl factory.\nif ( !InlineIsEqualGUID ( rclsid, \\_\\_uuidof(CMathComp) ))\n{\n    return CLASS\\_E\\_CLASSNOTAVAILABLE;\n}\n\n// Check that ppv really points to a void\\*.\nif ( IsBadWritePtr ( ppv, sizeof(void\\*) ))\n{\n    return E\\_POINTER;\n}\n\n\\*ppv = NULL;\n\n// Construct a new class factory object.\npFactory = new CMathCompClassFactory;\n\nif ( NULL == pFactory )\n{\n    return E\\_OUTOFMEMORY;\n}\n\n// AddRef() the factory since we\'re using it.\npFactory-&amp;gt;AddRef();\n\n// QueryInterface() the factory for the interface the client wants.\nhrRet = pFactory-&amp;gt;QueryInterface ( riid, ppv );\n\n// We\'re done with the factory, so Release() it.\npFactory-&amp;gt;Release();\n\nreturn hrRet;&lt;/code&gt;&lt;/pre&gt;\n\n}\n\n// DllCanUnloadNow() is called when COM wants to unload our DLL from memory.\n// We check our lock count, which will be nonzero if there are any COM\n// objects still in memory.\n// Return S\\_FALSE to prevent the DLL from being unloaded, or S\\_OK to let it\n// be unloaded.\nSTDAPI DllCanUnloadNow()\n{\nreturn g\\_uDllLockCount &amp;gt; 0 ? S\\_FALSE : S\\_OK;\n}\n\n// DllRegisterServer() creates the registy entries that tells COM where our\n// server is located and its threading model.\nSTDAPI DllRegisterServer()\n{\nHKEY hCLSIDKey = NULL, hInProcSvrKey = NULL;\nLONG lRet;\nTCHAR szModulePath \\[MAX\\_PATH\\];\nTCHAR szClassDescription\\[\\] = \\_T("MathServ class");\nTCHAR szThreadingModel\\[\\] = \\_T("Apartment");\n&lt;pre&gt;&lt;code&gt;\\_\\_try\n{\n    // Create a key under CLSID for our COM server.\n    lRet = RegCreateKeyEx ( HKEY\\_CLASSES\\_ROOT,\n            \\_T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}"), 0, NULL,\n            REG\\_OPTION\\_NON\\_VOLATILE, KEY\\_SET\\_VALUE | KEY\\_CREATE\\_SUB\\_KEY,\n            NULL, &amp;amp;hCLSIDKey, NULL );\n\n    if ( ERROR\\_SUCCESS != lRet )\n    {\n        return HRESULT\\_FROM\\_WIN32(lRet);\n    }\n\n    // The default value of the key is a human-readable\n    // description of the coclass.\n    lRet = RegSetValueEx ( hCLSIDKey, NULL, 0, REG\\_SZ,\n            (const BYTE\\*)szClassDescription, sizeof(szClassDescription));\n\n    if ( ERROR\\_SUCCESS != lRet )\n    {\n        return HRESULT\\_FROM\\_WIN32(lRet);\n    }\n\n    // Create the InProcServer32 key, which holds info about our coclass.\n    lRet = RegCreateKeyEx ( hCLSIDKey, \\_T("InProcServer32"), 0, NULL,\n            REG\\_OPTION\\_NON\\_VOLATILE, KEY\\_SET\\_VALUE,\n            NULL, &amp;amp;hInProcSvrKey, NULL );\n\n    if ( ERROR\\_SUCCESS != lRet )\n    {\n        return HRESULT\\_FROM\\_WIN32(lRet);\n    }\n\n    // The default value of the InProcServer32 key holds the\n    // full path to our DLL.\n    GetModuleFileName ( g\\_hinstThisDll, szModulePath, MAX\\_PATH );\n\n    lRet = RegSetValueEx(hInProcSvrKey, NULL, 0, REG\\_SZ, (const BYTE\\*)szModulePath,\n            sizeof(TCHAR) \\*(lstrlen(szModulePath)+1) );\n\n    if ( ERROR\\_SUCCESS != lRet )\n    {\n        return HRESULT\\_FROM\\_WIN32(lRet);\n    }\n\n    // The ThreadingModel value tells COM how it should handle threads\n    // in our DLL. The concept of apartments is beyond the scope of this\n    // article, but for simple, single-threaded DLLs, use Apartment.\n    lRet = RegSetValueEx ( hInProcSvrKey, \\_T("ThreadingModel"), 0, REG\\_SZ,\n        (const BYTE\\*) szThreadingModel,\n        sizeof(szThreadingModel) );\n\n    if ( ERROR\\_SUCCESS != lRet )\n    {\n        return HRESULT\\_FROM\\_WIN32(lRet);\n    }\n}\n\n\\_\\_finally\n{\n    if ( NULL != hCLSIDKey )\n    {\n        RegCloseKey ( hCLSIDKey );\n    }\n\n    if ( NULL != hInProcSvrKey )\n    {\n        RegCloseKey ( hInProcSvrKey );\n    }\n}\n\nreturn S\\_OK;&lt;/code&gt;&lt;/pre&gt;\n\n}\n\n// DllUnregisterServer() deleted the registy entries that DllRegisterServer() created.\nSTDAPI DllUnregisterServer()\n{\n// Delete our registry entries.\nRegDeleteKey ( HKEY\\_CLASSES\\_ROOT,\n\\_T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}InProcServer32"));\n&lt;pre&gt;&lt;code&gt;RegDeleteKey ( HKEY\\_CLASSES\\_ROOT,\n \\_T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}") );\n\nreturn S\\_OK;&lt;/code&gt;&lt;/pre&gt;\n\n}```\n\n**5\\. Add a .def \\[MathServ.def\\] to export functions**  \n**MathServ.def**\n\n```c\nEXPORTS\nDllRegisterServer PRIVATE\nDllUnregisterServer PRIVATE\nDllGetClassObject PRIVATE\nDllCanUnloadNow PRIVATE\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"6","."," In stdafx.h add module lock count and instance for DLL")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"&lt;h1&gt;pragma once&lt;/h1&gt;\n&lt;h1&gt;define WIN32\\_LEAN\\_AND\\_MEAN // Exclude rarely-used stuff from Windows headers&lt;/h1&gt;\n&lt;h1&gt;include &amp;lt;windows.h&amp;gt;&lt;/h1&gt;\n&lt;h1&gt;include &amp;lt;tchar.h&amp;gt;&lt;/h1&gt;\n&lt;h1&gt;include &amp;lt;comdef.h&amp;gt;&lt;/h1&gt;\n\nextern HINSTANCE g\\_hinstThisDll; // Our DLL's HINSTANCE\nextern UINT g\\_uDllLockCount; // The module lock count\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Develop a Console Client")," ",(0,a.kt)("strong",{parentName:"p"},"named 'comClient'"),"  ",(0,a.kt)("strong",{parentName:"p"},"for consuming the 'comMathServLib'")," "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"comClient.cpp")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'// comClient.cpp : Defines the entry point for the console application.\n&lt;h1&gt;include &amp;lt;comdef.h&amp;gt;&lt;/h1&gt;\n&lt;h1&gt;include "../comMathServLib/MathCompGuidDef.h"&lt;/h1&gt;\n&lt;h1&gt;include "../comMathServLib/IMath.h"&lt;/h1&gt;\n\nint main()\n{\nIMath\\* pIMath;\nHRESULT hr;\n&lt;pre&gt;&lt;code&gt;// 1. Initialize COM Library\nCoInitialize(NULL);\n\n// 2. Call CoCreateInstance to get the IMath interface pointer\nhr = CoCreateInstance ( \\_\\_uuidof(CMathComp), NULL, CLSCTX\\_INPROC\\_SERVER,\n                        \\_\\_uuidof(IMath), (void\\*\\*) &amp;amp;pIMath );\n\nif ( FAILED(hr) )\n{\n    return 0;\n}\n\n// 3. Call the interface functions\nint sum = pIMath-&amp;gt;Add(1, 3);\nprintf("Sum = %d n", sum);\n\nint sub = pIMath-&amp;gt;Sub(4, 3);\nprintf("Sub = %d n", sub);\n\n// 4. Release the interface pointer if you are done\npIMath-&amp;gt;Release();\n\n// 5. Un-Initialize COM Library\nCoUninitialize();\n\nreturn 0;&lt;/code&gt;&lt;/pre&gt;\n\n}\n')))}h.isMDXComponent=!0}}]);