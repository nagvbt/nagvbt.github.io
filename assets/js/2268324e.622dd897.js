"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["84892"],{50065:function(e,n,t){t.d(n,{Z:()=>s,a:()=>o});var r=t(67294);let i={},a=r.createContext(i);function o(e){let n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(a.Provider,{value:n},e.children)}},93477:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>o,default:()=>h,contentTitle:()=>s,assets:()=>l,toc:()=>c,metadata:()=>r});var r=JSON.parse('{"id":"Cpp/Polymorphism","title":"Polymorphism","description":"1.What are the types of Polymorphism ?","source":"@site/docs/Cpp/Polymorphism.md","sourceDirName":"Cpp","slug":"/Cpp/Polymorphism","permalink":"/docs/Cpp/Polymorphism","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"Cpp","previous":{"title":"FAQ","permalink":"/docs/Cpp/Functions/FAQ"},"next":{"title":"Templates and Exception Handling","permalink":"/docs/Cpp/Templates"}}'),i=t(85893),a=t(50065);let o={sidebar_position:7},s="Polymorphism",l={},c=[{value:"1.What are the types of Polymorphism ?",id:"1what-are-the-types-of-polymorphism-",level:3},{value:"2.What is Binding ?",id:"2what-is-binding-",level:3},{value:"3.What is the difference between Static and Dynamic Binding ?",id:"3what-is-the-difference-between-static-and-dynamic-binding-",level:3},{value:"4.What are Virtual Functions ?",id:"4what-are-virtual-functions-",level:3},{value:"5.What is a Pure virtual function ?",id:"5what-is-a-pure-virtual-function-",level:3},{value:"6.Pure Abstract base class ?",id:"6pure-abstract-base-class-",level:3},{value:"7.What is a Vtable pointer ?",id:"7what-is-a-vtable-pointer-",level:3},{value:"8.What is a virtual function table ?",id:"8what-is-a-virtual-function-table-",level:3},{value:"9.Can we have virtual constructors ?",id:"9can-we-have-virtual-constructors-",level:3},{value:"10.Write a program to Demonstrates Virtual Functions ?",id:"10write-a-program-to-demonstrates-virtual-functions-",level:3},{value:"11.Explain about Function Overloading ?",id:"11explain-about-function-overloading-",level:3},{value:"12.What are the senarios that Function Overloading misunderstood ?",id:"12what-are-the-senarios-that-function-overloading-misunderstood-",level:3},{value:"13.What is NAME MANGLING or NAME DECORATION ?",id:"13what-is-name-mangling-or-name-decoration-",level:3},{value:"14.Explain about Operator overloading ?",id:"14explain-about-operator-overloading-",level:3},{value:"15.What are the Operators that cannot be overloaded ?",id:"15what-are-the-operators-that-cannot-be-overloaded-",level:3},{value:"16.Write the Syntax for Operator overloading ?",id:"16write-the-syntax-for-operator-overloading-",level:3},{value:"17.Write a program to demonstrate Operator overloading ?",id:"17write-a-program-to-demonstrate-operator-overloading-",level:3}];function d(e){let n={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"polymorphism",children:"Polymorphism"})}),"\n",(0,i.jsx)(n.h3,{id:"1what-are-the-types-of-polymorphism-",children:"1.What are the types of Polymorphism ?"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"COMPILE-TIME Polymorphism: It will be implemened by using Function Overloading and Operator Overloading"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"RUN-TIME Polymorphism: It will be implemened by using Virtual Functions"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"2what-is-binding-",children:"2.What is Binding ?"}),"\n",(0,i.jsx)(n.p,{children:"The term binding refers to the connection between a function call and the actual code executed as a result of the call."}),"\n",(0,i.jsx)(n.h3,{id:"3what-is-the-difference-between-static-and-dynamic-binding-",children:"3.What is the difference between Static and Dynamic Binding ?"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Static or Early Binding:"})})}),"\n",(0,i.jsx)(n.p,{children:"Adavantage of function calls are fast when a function call gets resolved at compile-time it is called as static binding.\r\ne.g: Normal functions, overloaded functions, overloaded operator."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Dynamic or Late Binding:"})})}),"\n",(0,i.jsx)(n.p,{children:"When a function call gets resolved at runtime it is called as dynamic binding. e.g: virtual functions"}),"\n",(0,i.jsx)(n.h3,{id:"4what-are-virtual-functions-",children:"4.What are Virtual Functions ?"}),"\n",(0,i.jsx)(n.p,{children:"The form of the function that can be changed at runtime is called virtual function and the corresponding class is called polymorphic class."}),"\n",(0,i.jsx)(n.p,{children:"C++ provides a solution to invoke the exact version of the member function which as to be decided at runtime using virtual functions."}),"\n",(0,i.jsx)(n.p,{children:"They are the means by which functions of the base class can be overridden by the functions of the derived class."}),"\n",(0,i.jsx)(n.h3,{id:"5what-is-a-pure-virtual-function-",children:"5.What is a Pure virtual function ?"}),"\n",(0,i.jsxs)(n.p,{children:["A virtual function which is marked with the pure specifier (=0)\r\ne.g: ",(0,i.jsx)(n.code,{children:"virtual void __stdcall Add( ) = 0;"})]}),"\n",(0,i.jsx)(n.h3,{id:"6pure-abstract-base-class-",children:"6.Pure Abstract base class ?"}),"\n",(0,i.jsx)(n.p,{children:"It is a base class that contains only pure virtual functions."}),"\n",(0,i.jsx)(n.h3,{id:"7what-is-a-vtable-pointer-",children:"7.What is a Vtable pointer ?"}),"\n",(0,i.jsx)(n.p,{children:"It is a pointer to abstract base class points to the vtbl pointer which points to the virtual function table."}),"\n",(0,i.jsx)(n.h3,{id:"8what-is-a-virtual-function-table-",children:"8.What is a virtual function table ?"}),"\n",(0,i.jsx)(n.p,{children:"It is an array of pointers that point to the implementations of the virtual functions."}),"\n",(0,i.jsx)(n.h3,{id:"9can-we-have-virtual-constructors-",children:"9.Can we have virtual constructors ?"}),"\n",(0,i.jsx)(n.p,{children:"Constructor can not be virtual, because when constructor of a class is executed there is no vtable in the memory, means no virtual pointer defined yet. Hence the constructor should always be non-virtual."}),"\n",(0,i.jsx)(n.h3,{id:"10write-a-program-to-demonstrates-virtual-functions-",children:"10.Write a program to Demonstrates Virtual Functions ?"}),"\n",(0,i.jsx)(n.p,{children:"Purpose: Demonstrates Virtual Functions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"class Base {\r\npublic:\r\n virtual void vfun() {\r\n  cout << \"Base's vfun() \\n\";\r\n }\r\n};\r\n\r\nclass Der1 : public Base {\r\npublic:\r\n virtual void vfun() {\r\n  cout << \"D1's vfun() \\n\";\r\n }\r\n};\r\n\r\nclass Der2 : public Base {\r\npublic:\r\n virtual void vfun() {\r\n  cout << \"D2's vfun() \\n\";\r\n }\r\n};\r\n\r\nvoid main() {\r\n Base b, * bptr;\r\n Der1 d1;\r\n Der2 d2;\r\n\r\n bptr = &b;\r\n bptr->vfun(); // Base's vfun()\r\n\r\n bptr = &d1;\r\n bptr->vfun(); // D1's vfun()\r\n\r\n bptr = &d2;\r\n bptr->vfun(); // D2's vfun()\r\n}\r\n\r\nOUTPUT\r\nBase's vfun()\r\nD1's vfun()\r\nD2's vfun()\n"})}),"\n",(0,i.jsx)(n.h3,{id:"11explain-about-function-overloading-",children:"11.Explain about Function Overloading ?"}),"\n",(0,i.jsx)(n.p,{children:"Function overloading is the process of using the same name for two or more functions."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Use different types of parameters."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Use different number of parameters."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"12what-are-the-senarios-that-function-overloading-misunderstood-",children:"12.What are the senarios that Function Overloading misunderstood ?"}),"\n",(0,i.jsx)(n.p,{children:"A. Two functions differing only in their return types cannot be overloaded:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int fun1(int i)\r\nfloat fun2(int i)       \n"})}),"\n",(0,i.jsx)(n.p,{children:"B. Ambiguity due to Default arguments"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int fun1(int i)\r\nint fun2(int i, int j = 1)      \n"})}),"\n",(0,i.jsx)(n.p,{children:"C. Ambiguity due to normal & reference arguments"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int fun1(int i)\r\nint fun2(int &i)      \n"})}),"\n",(0,i.jsx)(n.p,{children:"D. Sometimes two function declarations will appear to be different when in fact they don\u2019t."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"int fun1(int *p)\r\nint fun2(int p[])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"13what-is-name-mangling-or-name-decoration-",children:"13.What is NAME MANGLING or NAME DECORATION ?"}),"\n",(0,i.jsx)(n.p,{children:"C++ Compiler changes names of all functions definitions and calls while compiling the program. This is known as NAME MANGLING or NAME DECORATION."}),"\n",(0,i.jsx)(n.h3,{id:"14explain-about-operator-overloading-",children:"14.Explain about Operator overloading ?"}),"\n",(0,i.jsx)(n.p,{children:"Operator overloading means giving capability to the operator to work on different types of operands other than basic types."}),"\n",(0,i.jsx)(n.p,{children:"The operators +, *  etc. work on operands of type int, float etc. we can overload these operators by giving them the capability to work on user-defined data types."}),"\n",(0,i.jsx)(n.h3,{id:"15what-are-the-operators-that-cannot-be-overloaded-",children:"15.What are the Operators that cannot be overloaded ?"}),"\n",(0,i.jsx)(n.p,{children:"Table:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"sizeof Size of operator"}),"\n",(0,i.jsx)(n.li,{children:"?: Conditional operator"}),"\n",(0,i.jsx)(n.li,{children:":: Scope resolution operator"}),"\n",(0,i.jsx)(n.li,{children:". Membership operator"}),"\n",(0,i.jsx)(n.li,{children:".* Pointer-to-member operator"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"16write-the-syntax-for-operator-overloading-",children:"16.Write the Syntax for Operator overloading ?"}),"\n",(0,i.jsx)(n.p,{children:"Syntax:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"ret_type className::operator op(arg_list)\r\n{\r\n\r\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where op is operator ( +, -, * \u2026)"}),"\n",(0,i.jsx)(n.h3,{id:"17write-a-program-to-demonstrate-operator-overloading-",children:"17.Write a program to demonstrate Operator overloading ?"}),"\n",(0,i.jsx)(n.p,{children:"Purpose: demonstrate Operator overloading"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"struct data {int i; };\r\n\r\n//Post Increment\r\n    data operator ++ (data x, int) {\r\n    data t;\r\n    t.i = x.i;\r\n    x.i = x.i + 1;\r\n    return t;\r\n}\r\n\r\n//Pre Increment\r\ndata operator ++ (data x) {\r\n    data t;\r\n    x.i = x.i + 1;\r\n    t.i = x.i;\r\n    return t;\r\n}\r\n\r\nvoid main() {\r\n    data d;\r\n    d.i = 1;\r\n    //d++;\r\n    ++d;\r\n    cout<<d.i;\r\n}\n"})})]})}function h(e={}){let{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);