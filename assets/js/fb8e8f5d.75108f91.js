"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[14897],{3905:(n,e,t)=>{t.d(e,{Zo:()=>s,kt:()=>f});var i=t(67294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function p(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},o=Object.keys(n);for(i=0;i<o.length;i++)t=o[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(i=0;i<o.length;i++)t=o[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var d=i.createContext({}),l=function(n){var e=i.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},s=function(n){var e=l(n.components);return i.createElement(d.Provider,{value:e},n.children)},m="mdxType",c={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},u=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,o=n.originalType,d=n.parentName,s=p(n,["components","mdxType","originalType","parentName"]),m=l(t),u=r,f=m["".concat(d,".").concat(u)]||m[u]||c[u]||o;return t?i.createElement(f,a(a({ref:e},s),{},{components:t})):i.createElement(f,a({ref:e},s))}));function f(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var o=t.length,a=new Array(o);a[0]=u;var p={};for(var d in e)hasOwnProperty.call(e,d)&&(p[d]=e[d]);p.originalType=n,p[m]="string"==typeof n?n:r,a[1]=p;for(var l=2;l<o;l++)a[l]=t[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},88407:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var i=t(87462),r=(t(67294),t(3905));const o={tags:["Data Structures","C++"]},a=void 0,p={permalink:"/blog/2012/04/04/linkedlist",source:"@site/blog/2012-04-04-linkedlist.md",title:"linkedlist",description:"Definition:",date:"2012-04-04T00:00:00.000Z",formattedDate:"April 4, 2012",tags:[{label:"Data Structures",permalink:"/blog/tags/data-structures"},{label:"C++",permalink:"/blog/tags/c"}],readingTime:2.785,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["Data Structures","C++"]},prevItem:{title:"abstractfactory-designpatter",permalink:"/blog/2012/04/04/abstractfactory-designpatter"},nextItem:{title:"'Builder' Design Pattern using simple program",permalink:"/blog/2012/04/03/builderdesignpatter"}},d={authorsImageUrls:[]},l=[],s={toc:l},m="wrapper";function c(n){let{components:e,...t}=n;return(0,r.kt)(m,(0,i.Z)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"simple-linkedlist-program-in-c"},"Simple LinkedList program in C++"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition:")),(0,r.kt)("p",null,"A linked list is a data structure that consists of a sequence of data records such that in each record there is a field that contains a reference (i.e., a link) to the next record in the sequence."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "stdafx.h"\n#include "iostream"\nusing namespace std;\n\nclass LinkList\n{\nprivate:\n      struct Node\n      {\n        int data;\n        Node* link;\n      }*p;\n\npublic:\n      LinkList();\n      ~LinkList();\n\n       void Print();         // Prints the contents of linkedlist\n       void Append(int num); // Adds a new node at the end of the linkedlist\n       void Delete(int num); // Deletes the specified node from the linkedlist\n\n       void AddatBeg(int num);// Adds a new node at the beginning of the linkedlist\n       void AddAfter(int c, int num); // Adds a new node after specified number of nodes\n       int Count();          // Counts number of nodes present in the linkedlist\n\n};\n\nLinkList::LinkList()\n{\n  p = NULL;\n}\n\nLinkList::~LinkList()\n{\n  if (p == NULL)\n        return;\n\n  Node* tmp;\n  while(p != NULL)\n  {\n       tmp = p->link ;\n       delete p;\n       p = tmp;\n  }\n}\n\n// Prints the contents of linkedlist\nvoid LinkList::Print()\n{\n  if (p == NULL)\n  {\n        cout<< "EMPTY";\n        return;\n  }\n\n  //Traverse\n  Node* tmp = p;\n  while(tmp != NULL)\n  {\n       cout<data<<endl;\n       tmp = tmp->link ;\n  }\n}\n\n// Adds a new node at the end of the linkedlist\nvoid LinkList::Append(int num)\n{\n      Node *newNode;\n\n      newNode = new Node;\n      newNode->data = num;\n      newNode->link = NULL;\n\n       if(p == NULL)\n      {\n       //create first node\n         p = newNode;\n      }\n       else\n      {\n             //Traverse\n            Node *tmp = p;\n             while(tmp->link != NULL)\n            {\n                  tmp = tmp->link;\n            }\n\n             //add node to the end\n        tmp->link = newNode;\n      }\n}\n\n// Deletes the specified node from the linkedlist\nvoid LinkList::Delete( int num )\n{\n   Node *tmp;\n\n   tmp = p;\n   //If node to be delete is first node\n   if( tmp->data == num )\n   {\n      p = tmp->link;\n      delete tmp;\n      return;\n   }\n\n   // traverse list till the last but one node is reached\n   Node *tmp2 = tmp;\n   while( tmp!=NULL )\n   {\n      if( tmp->data == num )\n      {\n         tmp2->link = tmp->link;\n         delete tmp;\n         return;\n      }\n\n      tmp2 = tmp;\n      tmp = tmp->link;\n   }\n   cout<< "nElement "<<num<<" not Found." ;\n}\n\n// Adds a new node at the beginning of the linkedlist\nvoid LinkList::AddatBeg(int num)\n{\n      Node *tmp;\n\n       //add new node\n      tmp = new Node;\n      tmp->data = num;\n      tmp->link = p;\n      p = tmp;\n}\n\n//Adds a new node after specified number of nodes\nvoid LinkList::AddAfter(int c, int num)\n{\n      Node *tmp;\n      Node *tmp2;\n       int i;\n       //Skip to the desired portion\n       for( i = 0, tmp = p; i\n       {\n            tmp = tmp->link;\n\n             //if end of linked list is encountered\n             if(tmp == NULL)\n            {\n                  cout<<endl<< "There are less than "<<c<<" elements" ;\n                   return;\n            }\n      }\n\n       //insert new node\n      tmp2 = new Node;\n      tmp2->data = num;\n      tmp2->link = tmp->link;\n      tmp->link = tmp2;\n}\n\n// Counts number of nodes present in the linkedlist\nint LinkList::Count()\n{\n      Node *tmp;\n       int c = 0;\n\n       //Traverse the entire Linked List\n       for (tmp = p; tmp != NULL; tmp = tmp->link)\n            c++;\n\n       return (c);\n}\n\nvoid main()\n{\n      LinkList* pobj = new LinkList();\n      pobj->Append(11);\n      pobj->Append(22);\n      pobj->Append(33);\n      pobj->Delete(33);\n      pobj->AddatBeg(44);\n      pobj->AddAfter(1, 55);\n      pobj->Print();\n      cout<<endl<< "no. of elements in linked list="<<pobj->Count()<<endl;\n\n       delete pobj;\n}\n\n/*\nOUTPUT\n----------------\n44\n11\n55\n22\n\nNo. of elements in linked list = 4\n*/\n')))}c.isMDXComponent=!0}}]);