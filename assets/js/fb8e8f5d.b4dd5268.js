"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[14897],{30766:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>d,metadata:()=>s,toc:()=>a});var t=r(85893),i=r(11151);const d={tags:["Data Structures","C++"]},o="Simple LinkedList program in C++",s={permalink:"/blog/2012/04/04/linkedlist",source:"@site/blog/2012-04-04-linkedlist.md",title:"Simple LinkedList program in C++",description:"Definition:",date:"2012-04-04T00:00:00.000Z",formattedDate:"April 4, 2012",tags:[{label:"Data Structures",permalink:"/blog/tags/data-structures"},{label:"C++",permalink:"/blog/tags/c"}],readingTime:2.755,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["Data Structures","C++"]},unlisted:!1,prevItem:{title:"\u2018AbstractFactory\u2019 Design Pattern using simple program",permalink:"/blog/2012/04/04/abstractfactory-designpatter"},nextItem:{title:"'Builder' Design Pattern using simple program",permalink:"/blog/2012/04/03/builderdesignpatter"}},p={authorsImageUrls:[]},a=[];function l(n){const e={code:"code",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Definition:"})}),"\n",(0,t.jsx)(e.p,{children:"A linked list is a data structure that consists of a sequence of data records such that in each record there is a field that contains a reference (i.e., a link) to the next record in the sequence."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include "stdafx.h"\r\n#include "iostream"\r\nusing namespace std;\r\n\r\nclass LinkList\r\n{\r\nprivate:\r\n      struct Node\r\n      {\r\n        int data;\r\n        Node* link;\r\n      }*p;\r\n\r\npublic:\r\n      LinkList();\r\n      ~LinkList();\r\n\r\n       void Print();         // Prints the contents of linkedlist\r\n       void Append(int num); // Adds a new node at the end of the linkedlist\r\n       void Delete(int num); // Deletes the specified node from the linkedlist\r\n\r\n       void AddatBeg(int num);// Adds a new node at the beginning of the linkedlist\r\n       void AddAfter(int c, int num); // Adds a new node after specified number of nodes\r\n       int Count();          // Counts number of nodes present in the linkedlist\r\n\r\n};\r\n\r\nLinkList::LinkList()\r\n{\r\n  p = NULL;\r\n}\r\n\r\nLinkList::~LinkList()\r\n{\r\n  if (p == NULL)\r\n        return;\r\n\r\n  Node* tmp;\r\n  while(p != NULL)\r\n  {\r\n       tmp = p->link ;\r\n       delete p;\r\n       p = tmp;\r\n  }\r\n}\r\n\r\n// Prints the contents of linkedlist\r\nvoid LinkList::Print()\r\n{\r\n  if (p == NULL)\r\n  {\r\n        cout<< "EMPTY";\r\n        return;\r\n  }\r\n\r\n  //Traverse\r\n  Node* tmp = p;\r\n  while(tmp != NULL)\r\n  {\r\n       cout<data<<endl;\r\n       tmp = tmp->link ;\r\n  }\r\n}\r\n\r\n// Adds a new node at the end of the linkedlist\r\nvoid LinkList::Append(int num)\r\n{\r\n      Node *newNode;\r\n\r\n      newNode = new Node;\r\n      newNode->data = num;\r\n      newNode->link = NULL;\r\n\r\n       if(p == NULL)\r\n      {\r\n       //create first node\r\n         p = newNode;\r\n      }\r\n       else\r\n      {\r\n             //Traverse\r\n            Node *tmp = p;\r\n             while(tmp->link != NULL)\r\n            {\r\n                  tmp = tmp->link;\r\n            }\r\n\r\n             //add node to the end\r\n        tmp->link = newNode;\r\n      }\r\n}\r\n\r\n// Deletes the specified node from the linkedlist\r\nvoid LinkList::Delete( int num )\r\n{\r\n   Node *tmp;\r\n\r\n   tmp = p;\r\n   //If node to be delete is first node\r\n   if( tmp->data == num )\r\n   {\r\n      p = tmp->link;\r\n      delete tmp;\r\n      return;\r\n   }\r\n\r\n   // traverse list till the last but one node is reached\r\n   Node *tmp2 = tmp;\r\n   while( tmp!=NULL )\r\n   {\r\n      if( tmp->data == num )\r\n      {\r\n         tmp2->link = tmp->link;\r\n         delete tmp;\r\n         return;\r\n      }\r\n\r\n      tmp2 = tmp;\r\n      tmp = tmp->link;\r\n   }\r\n   cout<< "nElement "<<num<<" not Found." ;\r\n}\r\n\r\n// Adds a new node at the beginning of the linkedlist\r\nvoid LinkList::AddatBeg(int num)\r\n{\r\n      Node *tmp;\r\n\r\n       //add new node\r\n      tmp = new Node;\r\n      tmp->data = num;\r\n      tmp->link = p;\r\n      p = tmp;\r\n}\r\n\r\n//Adds a new node after specified number of nodes\r\nvoid LinkList::AddAfter(int c, int num)\r\n{\r\n      Node *tmp;\r\n      Node *tmp2;\r\n       int i;\r\n       //Skip to the desired portion\r\n       for( i = 0, tmp = p; i\r\n       {\r\n            tmp = tmp->link;\r\n\r\n             //if end of linked list is encountered\r\n             if(tmp == NULL)\r\n            {\r\n                  cout<<endl<< "There are less than "<<c<<" elements" ;\r\n                   return;\r\n            }\r\n      }\r\n\r\n       //insert new node\r\n      tmp2 = new Node;\r\n      tmp2->data = num;\r\n      tmp2->link = tmp->link;\r\n      tmp->link = tmp2;\r\n}\r\n\r\n// Counts number of nodes present in the linkedlist\r\nint LinkList::Count()\r\n{\r\n      Node *tmp;\r\n       int c = 0;\r\n\r\n       //Traverse the entire Linked List\r\n       for (tmp = p; tmp != NULL; tmp = tmp->link)\r\n            c++;\r\n\r\n       return (c);\r\n}\r\n\r\nvoid main()\r\n{\r\n      LinkList* pobj = new LinkList();\r\n      pobj->Append(11);\r\n      pobj->Append(22);\r\n      pobj->Append(33);\r\n      pobj->Delete(33);\r\n      pobj->AddatBeg(44);\r\n      pobj->AddAfter(1, 55);\r\n      pobj->Print();\r\n      cout<<endl<< "no. of elements in linked list="<<pobj->Count()<<endl;\r\n\r\n       delete pobj;\r\n}\r\n\r\n/*\r\nOUTPUT\r\n----------------\r\n44\r\n11\r\n55\r\n22\r\n\r\nNo. of elements in linked list = 4\r\n*/\n'})})]})}function m(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}},11151:(n,e,r)=>{r.d(e,{Z:()=>s,a:()=>o});var t=r(67294);const i={},d=t.createContext(i);function o(n){const e=t.useContext(d);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),t.createElement(d.Provider,{value:e},n.children)}}}]);