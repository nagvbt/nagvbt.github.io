"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[93272],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>y});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(r),d=a,y=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return r?n.createElement(y,i(i({ref:t},c),{},{components:r})):n.createElement(y,i({ref:t},c))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},45477:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const o={title:"How to avoid Memory\xa0Leaks in C++, VC++",date:"2014-10-17",categories:["c-cpp-mfc-vcpp"],tags:["c","vc"]},i=void 0,l={permalink:"/blog/2014/10/17/how-to-avoid-memory-leaks-in-c-vc",source:"@site/blog/2014-10-17-how-to-avoid-memory-leaks-in-c-vc.md",title:"How to avoid Memory\xa0Leaks in C++, VC++",description:"Contents",date:"2014-10-17T00:00:00.000Z",formattedDate:"October 17, 2014",tags:[{label:"c",permalink:"/blog/tags/c"},{label:"vc",permalink:"/blog/tags/vc"}],readingTime:3.08,hasTruncateMarker:!1,authors:[],frontMatter:{title:"How to avoid Memory\xa0Leaks in C++, VC++",date:"2014-10-17",categories:["c-cpp-mfc-vcpp"],tags:["c","vc"]},prevItem:{title:"How to make Visual Studio Run Faster",permalink:"/blog/2015/03/10/how-to-make-visual-studio-run-faster"},nextItem:{title:"How to Learn Windows Phone 8.1 apps development",permalink:"/blog/2014/06/12/how-learn-windows-phone-8-1-apps-development"}},s={authorsImageUrls:[]},p=[],c={toc:p},m="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Contents")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Introduction"),(0,a.kt)("li",{parentName:"ol"},"How to find memory leak"),(0,a.kt)("li",{parentName:"ol"},"Memory Leak and how to avoid it")),(0,a.kt)("p",null,"Updated on : ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("strong",{parentName:"em"},"17-Oct-2014"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"1","."," Introduction")),(0,a.kt)("p",null,"The failure to properly deallocate memory that was previously allocated is known as Memory Leak. The consequences of memory leaks is that the programs that leak large amounts of memory, or leak progressively, may display symptoms ranging from poor (and gradually decreasing) performance to running out of memory completely. Worse, a leaking program may use up so much memory that it causes another program to fail, leaving the user with no clue to where the problem truly lies. In addition, even harmless memory leaks may be symptomatic of other problems."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"2","."," How to Find Memory Leak")),(0,a.kt)("p",null,"Use third-party tools like DevPartner or use the following steps to find the memory leaks"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},'Compile the project in "Debug" Mode.'),(0,a.kt)("li",{parentName:"ul"},"Declare the objects ",(0,a.kt)("strong",{parentName:"li"},"CMemoryState msOld, msNew, msDif;")),(0,a.kt)("li",{parentName:"ul"},"Check the memory state at one point. ",(0,a.kt)("strong",{parentName:"li"},"msOld.Checkpoint();")," ://code ://code"),(0,a.kt)("li",{parentName:"ul"},"Check the memory state at onother point. ",(0,a.kt)("strong",{parentName:"li"},"msNew.Checkpoint();")),(0,a.kt)("li",{parentName:"ul"},"See for Difference ",(0,a.kt)("strong",{parentName:"li"},"msDif.Difference( msOld, msNew );")),(0,a.kt)("li",{parentName:"ul"},"Display the Leaked blocks in Debug window \xa0",(0,a.kt)("strong",{parentName:"li"},"msDif.DumpStatistics();"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"3","."," Memory Leak and How to avoid it")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"a. Wrong usage of new/delete.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"c int\\* intArr; intArr = new int\\[500\\]; delete intArr; ")),(0,a.kt)("p",null,"Use\xa0 delete","[","]","intArr; instead of delete\xa0intArr as delete intArr is equal to deleting intArr ","[","0","]",";"),(0,a.kt)("p",null," ",(0,a.kt)("strong",{parentName:"p"},"b. Improper deletion of Array of Pointers")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"introwNo = 3; \nintcolsNo = 3; \nint\\*_array = newint_\\[rowNo\\];\n\nfor(inti=0; i < rowNo; i++) { array\\[i\\] = new int\\[i+1\\]; }\n\ndelete\\[\\] array; \n")),(0,a.kt)("p",null,"The cause of memory leak is that the 'array' is an array of pointers, with each of it's elements pointing to a separate memory block, so it is necessary free these blocks before freeing the array that holds the pointers."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"for(int i=0; i < rowNo; i++) \n{\n   delete\\[\\] array\\[i\\];\n} \n    \ndelete \\[\\] array; \n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"c. Resource Handles: GDI Objects- CBrush, CPen, CFont, CBitmap, CPallete, CRgn and respective handles")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"c CBrush myBr, \\*pOldBr; myBr .CreateSolidBrush(RGB(0, 255, 0)); pOldBr = pDC->SelectObject(&myBr); pDC->SelectObject(& myBr ); : : pDC->SelectObject(pOldBrush); ")),(0,a.kt)("p",null,"For more details Check:",(0,a.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx"}),(0,a.kt)("a",{parentName:"p",href:"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx"},"http://msdn.microsoft.com/en-us/library/windows/desktop/ms724291(v=vs.85).aspx")),(0,a.kt)("p",null,"The DeleteObject method deletes the GDI object by freeing all system storage associated with it. The storage associated with the CGdiObject object is not affected by this call. An application should not call DeleteObject on a CGdiObject object that is currently selected into a device context. Use myBr.DeleteObject(); after finishing using myBr (Cbrush) object\xa0For handles pass handle of the DeleteObject function DeleteObject(hPen);"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"d. String conversions CString to LPTSTR")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},'c CString sName; sName= \\_T("Hello"); int lenName = sName.GetLength();LPTSTR lpstrg = sName.GetBuffer(lenName); :: sName.ReleaseBuffer(); Cstring to BSTR CString csStr = "Hello"; BSTR bStr = csStr.AllocSysString(); : : ::SysFreeString(bStr); //finished using the BSTR ')),(0,a.kt)("p",null,"Use ReleaseBuffer() when ever we create a buffer. Use ::SysFreeString() when ever we use AllocSysString() which allocates a new string of the type BSTR."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"e. Improper deletion of pointer objects in a CList")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"c CList<CMyData_, CMyData_\\> ptList; CList<CMyData_, CMyData_\\> ptList; : : ptList.RomoveAll(); //Improper deletion of pointer objects in a CArray CArray<CMyData_, CMyData_\\> ptArr; : : ptArr.RemoveAll(); ")),(0,a.kt)("p",null,"Proper deletion of pointer objects in a CList"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c",metastring:"CList<CMyData_, CMyData_> ptList; : : POSITION pos = ptList.GetHeadPosition();","CList<CMyData_,":!0,"CMyData_>":!0,"ptList;":!0,":":!0,POSITION:!0,pos:!0,"":"","ptList.GetHeadPosition();":!0},"\nwhile(pos!=NULL) { delete ptList.GetNext(pos); }\n\nPtList.RomoveAll();\n\n// Proper deletion of pointer objects in a CArray CArray<CMyData_, CMyData_\\> ptArr; : : int i = 0;\n\nwhile(i<ptArr.GetSize()) { delete ptArr.GetAt(i++); }\n\nptArr.RemoveAll(); ```\n\n**f. Opening and proper closing of file and databases**\n\n| ```c CFile file; file.Open(szFilePath, CFile::modeCreate | CFile::modeWrite, 0); |\n| --- | --- |\n\n: file.Write(chFile, chFileSize); file.Close(); ```\n\n**e. Usage of Static Arrays**\n\n```c int Sample\\[500\\]; ```\n\nNever use static arrays if the array is dynamically growing. Instead of using static arrays use CArray or OCArray Example:\n\n```c CArray<int, int> Sample; ```\n")))}u.isMDXComponent=!0}}]);