"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[86887],{12376:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var s=t(85893),r=t(11151);const a={tags:["COM"]},o="COM Threading Model vs Win32/MFC Threads",i={permalink:"/blog/2012/06/18/com-threading-model-vs-win32mfc-threads",source:"@site/blog/2012-06-18-com-threading-model-vs-win32mfc-threads.md",title:"COM Threading Model vs Win32/MFC Threads",description:"1. Win32/MFC Threads",date:"2012-06-18T00:00:00.000Z",formattedDate:"June 18, 2012",tags:[{label:"COM",permalink:"/blog/tags/com"}],readingTime:1.095,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["COM"]},unlisted:!1,prevItem:{title:"COM Threading Models",permalink:"/blog/2012/06/19/threading-modelsapartment-model"},nextItem:{title:"Unit Testing Native C++ App with out clr",permalink:"/blog/2012/06/18/unit-testing-nativE-C++"}},h={authorsImageUrls:[]},d=[{value:"1. Win32/MFC Threads",id:"1-win32mfc-threads",level:2},{value:"2. COM Threads",id:"2-com-threads",level:2}];function l(e){const n={h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"1-win32mfc-threads",children:"1. Win32/MFC Threads"}),"\n",(0,s.jsx)(n.p,{children:"There are two types of win32/MFC threads."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"User-interface thread:"})," these types of threads are associated with one or more windows. These threads have message loops that keep the window alive and responsive to the users input."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Worker thread:"})," these threads are associated with background processing and are not associated with a window. These types oh threads does not use message loops."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"NOTE: A single process can have multiple user interface threads, multiple worker threads."}),"\n",(0,s.jsx)(n.h2,{id:"2-com-threads",children:"2. COM Threads"}),"\n",(0,s.jsx)(n.p,{children:"COM uses same type of threads with different names."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Apartment threads (User Interface Thread):"})," This thread owns the component it creates. COM synchronizes, all calls to the component. The component does not need to be threading safe. COM does all of the marshaling and synchronization."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Free threads (Worker Thread):"})," COM does not synchronize the calls. Ant thread can access the component. These are free to use. The component must be threading safe. Marshalling is not necessary and component\u2019s job to synchronize."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"NOTE: One process can have single apartment or multiple apartments. In-proc server is example for single process with different apartments (server apartment, client apartment both are in same exe)."}),"\n",(0,s.jsx)(n.p,{children:"Out of-proc server is example for single process with single thread."})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>o});var s=t(67294);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);