"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["32417"],{23880:function(n,e,r){r.r(e),r.d(e,{frontMatter:()=>l,default:()=>d,toc:()=>c,metadata:()=>i,assets:()=>o,contentTitle:()=>a});var i=JSON.parse('{"id":"COM-ATL/ATL","title":"ATL Tutorial","description":"Basics of ATL","source":"@site/docs/COM-ATL/ATL.md","sourceDirName":"COM-ATL","slug":"/COM-ATL/ATL","permalink":"/docs/COM-ATL/ATL","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"COMTutorial","permalink":"/docs/COM-ATL/COMTutorial"},"next":{"title":"ActiveX Control Tutorial","permalink":"/docs/COM-ATL/ActiveX"}}'),t=r(85893),s=r(50065);let l={sidebar_position:3},a="ATL Tutorial",o={},c=[{value:"Basics of ATL",id:"basics-of-atl",level:2},{value:"<strong>FAQ</strong>",id:"faq",level:3}];function h(n){let e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"atl-tutorial",children:"ATL Tutorial"})}),"\n",(0,t.jsx)(e.h2,{id:"basics-of-atl",children:"Basics of ATL"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"What you will Learn Here\u2026"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Definition of ATL"}),"\n",(0,t.jsx)(e.li,{children:"ATL Features"}),"\n",(0,t.jsx)(e.li,{children:"Basic Definitions of ATL"}),"\n",(0,t.jsx)(e.li,{children:"ATL's Component Class Hierarchy"}),"\n",(0,t.jsx)(e.li,{children:"FAQ"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"1. Definition of ATL"})," The Active Template Library (ATL) is a set of template-based C++ classes that allows to create small, fast Component Object Model (COM) objects."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"2. ATL Features"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"ATL provides two types of wizards"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"a. AppWizard: AppWizard creates the initial ATL project.\r\nb. Object Wizard: Object Wizard produces code for basic COM components."}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Built-in support for basic COM functionality such as IUnknown, class factories, IDispatch (automation), dual interfaces and self-registration."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Inbuilt Support for Microsoft\u2019s Interface Definition Language (IDL) which provides marshaling support for custom Vtable interfaces as well as component self-description through a type library."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Aggregation of objects and Automation support"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Support for developing ActiveX controls."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"3. Basic Definitions of ATL"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"Marshaling:"})})," Marshaling is the process of transferring function arguments and return values across process and machine boundaries."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:"proxy/stub"})})," DLL implements standard marshaling for each of the component interfaces."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"COM will use the IPC to communicate between client and server."}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"LPC is used when both reside on the same machine."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"RPC is used in a distributed networked\xa0environment"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"4. ATL's Component Class Hierarchy"})}),"\n",(0,t.jsx)(e.p,{children:"ATL never Creates the instance of the CoClass Directly. Instead ATL uses CComObject template class with 'CMathComp' object type as a parameter to create our Object."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"CComObject * pMath = new ComObject"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.em,{children:"CComObjectRootEx"})})," - Handles object reference count management. ",(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"CComCoClass"})})," - Provides methods for creating instances of a class and obtaining its properties it has createInstance() method which creates the instance of a COM Object through ClassFactory ",(0,t.jsx)(e.em,{children:(0,t.jsx)(e.strong,{children:"CComObject"})})," - Implements IUnknown for an COM object."]}),"\n",(0,t.jsx)(e.p,{children:"In this tutorial we will be creating"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"MathComp which is a DLL or Inproc server and exposes the Add and Sub functions."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"An MFC Dialog Based Application which acts like a Client for MathComp"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Steps for creating MathComp"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Open VS 2008"}),"\n",(0,t.jsxs)(e.li,{children:["File->NewProject Click OK -> Click Next ",(0,t.jsx)(e.strong,{children:"Select Server type:"})," as DLL ",(0,t.jsx)(e.strong,{children:"Select Addition options:"})," as 'Allow merging of proxy/stub code' and click Finish"]}),"\n",(0,t.jsx)(e.li,{children:"Add Component Class"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["Select ",(0,t.jsx)(e.code,{children:"ATL simple Object"})]}),"\n",(0,t.jsx)(e.p,{children:"Enter Short name: \"CMath\" to add the component class -> Click 'Finish'"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Add a Method to ICMath Interface"})}),"\n",(0,t.jsx)(e.p,{children:"The classes created are shown below in the class diagram."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"CCMath"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// CCMath\r\nclass ATL_NO_VTABLE CCMath :\r\n       public CComObjectRootEx<CComSingleThreadModel>,\r\n       public CComCoClass<CCMath, &CLSID_CMath>,\r\n       public IDispatchImpl<ICMath, &IID_ICMath, &LIBID_MathCompLib, /*wMajor =*/ 1, /*wMinor =*/ 0>\r\n{\r\npublic :\r\n      CCMath()\r\n      {\r\n      }\r\n\r\nDECLARE_REGISTRY_RESOURCEID(IDR_CMATH)\r\n\r\nBEGIN_COM_MAP(CCMath)\r\n      COM_INTERFACE_ENTRY(ICMath)\r\n      COM_INTERFACE_ENTRY(IDispatch)\r\nEND_COM_MAP()\r\n\r\nDECLARE_PROTECT_FINAL_CONSTRUCT()\r\n\r\n      HRESULT FinalConstruct()\r\n      {\r\n             return S_OK;\r\n      }\r\n\r\n       void FinalRelease()\r\n      {\r\n      }\r\n\r\npublic :\r\n\r\n      STDMETHOD(Add)(DOUBLE i, DOUBLE j, DOUBLE* result);\r\n      STDMETHOD(Sub)(DOUBLE i, DOUBLE j, DOUBLE* result);\r\n};\r\n\r\nOBJECT_ENTRY_AUTO( __uuidof(CMath), CCMath)\r\n\r\nCMath.h\r\n// CCMath\r\nSTDMETHODIMP CCMath::Add(DOUBLE i, DOUBLE j, DOUBLE* result)\r\n{\r\n      *result = i + j;\r\n       return S_OK;\r\n}\r\n\r\nSTDMETHODIMP CCMath::Sub(DOUBLE i, DOUBLE j, DOUBLE* result)\r\n{\r\n      *result = i - j;\r\n       return S_OK;\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"MathComp.idl"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// MathComp.idl : IDL source for MathComp\r\n// This file will be processed by the MIDL tool to\r\n// produce the type library (MathComp.tlb) and marshalling code.\r\n\r\nimport "oaidl.idl" ;\r\nimport "ocidl.idl" ;\r\n\r\n[\r\n       object ,\r\n       uuid (F3BDE3CF-884A-461A-A377-1F96A72239B0),\r\n       dual ,\r\n       nonextensible ,\r\n       helpstring ("ICMath Interface" ),\r\n       pointer_default (unique )\r\n]\r\ninterface ICMath : IDispatch{\r\n      [ id (1), helpstring ( "method Add")] HRESULT Add([ in ] DOUBLE i, [in ] DOUBLE j, [out ] DOUBLE* result);\r\n      [ id (2), helpstring ( "method Sub")] HRESULT Sub([ in ] DOUBLE i, [in ] DOUBLE j, [out ] DOUBLE* result);\r\n};\r\n[\r\n       uuid (44FF4D78-6AAD-4D2B-9150-DEBCCE79D8E0),\r\n       version (1.0),\r\n       helpstring ("MathComp 1.0 Type Library" )\r\n]\r\nlibrary MathCompLib\r\n{\r\n       importlib ("stdole2.tlb" );\r\n      [\r\n             uuid (4A8C8314-6C03-4AF7-96A1-9D6052A89363),\r\n             helpstring ("CMath Class" )\r\n      ]\r\n       coclass CMath\r\n      {\r\n            [ default ] interface ICMath;\r\n      };\r\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"NOTE: Other classes are not shown here please Download the source for complete code."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Steps for creating MFC Client"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Create an MFC Dialog based application"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Design the Dialog as shown below"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Add a Add button Handler (OnBnClickedButtonAdd) 4. Inside Add button handler add the below code"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'//Step1: import include .tlb file\r\n#import "..MathCompMathComp.tlb" no_namespace\r\n\r\nvoid CCMathClientDlg::OnBnClickedButtonAdd()\r\n{\r\n      //Step2/////////////// Initialize the COM libraries ///////////////////////////////\r\n     CoInitialize(NULL);\r\n\r\n      //Step3/////////////////////////Retriving CLSID from ProgID///////////////////////\r\n      CLSID clsid;\r\n      CLSIDFromProgID(OLESTR("MathComp.CMath.1"),&clsid); // will be in CMath.rgs file\r\n\r\n      //Step4/////////////////////////////Creating instance of server///////////////////\r\n      ICMath *pICMath;\r\n\r\n      HRESULT hr = CoCreateInstance(\r\n                     clsid,             //The CLSID associated with the data and code that will be used to create the object.\r\n                     NULL,              //If NULL, indicates that the object is not being created as part of an aggregate\r\n                     CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER, //ontext in which the code that manages the newly created object will run\r\n                     __uuidof(ICMath),  //riid: A reference to the identifier of the interface to be used to communicate with the object.\r\n                     (LPVOID*)&pICMath); //*ppv: Address of pointer variable that receives the interface pointer requested in riid.\r\n                                       //Upon successful return, *ppv contains the requested interface pointer. Upon failure, *ppv contains NULL.\r\n\r\n      if (FAILED(hr))\r\n      {\r\n            AfxMessageBox(_T("ICMath Failed"));\r\n      }\r\n\r\n      //Step5/////////////////////////////Using COM Component//////////////////////////\r\n      UpdateData(TRUE);\r\n\r\n      double res =0;\r\n      pICMath->Add(m_i, m_j, &res);\r\n      m_Result = res;\r\n\r\n      pICMath->Release(); // To avoid memory leak\r\n      pICMath = NULL;\r\n\r\n      //Step6////////////////////////////Uninit\'ializing the COM libraries//////////////\r\n      CoUninitialize();\r\n\r\n      UpdateData(FALSE);\r\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"faq",children:(0,t.jsx)(e.strong,{children:"FAQ"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What is ATL ? check - 1. Definition of ATL"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What is MIDL ? check - 2. ATL Features - 3 point"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What are the featurs of ATL ? check - 2. ATL Feature"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What is Marshiling ? check - 3. Basic Definitions of ATL - 1 point"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Explain about\xa0ATL's Class Hierarchy? check - 4.ATL's Component Class Hierarchy"}),"\n"]}),"\n"]})]})}function d(n={}){let{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}},50065:function(n,e,r){r.d(e,{Z:()=>a,a:()=>l});var i=r(67294);let t={},s=i.createContext(t);function l(n){let e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:l(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);