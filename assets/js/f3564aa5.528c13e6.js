"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[59968],{21639:r=>{r.exports=JSON.parse('{"permalink":"/blog/2012/04/04/abstractfactory-designpatter","source":"@site/blog/2012-04-04-abstractfactory-designpatter.md","title":"\u2018AbstractFactory\u2019 Design Pattern using simple program","description":"Definition: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.","date":"2012-04-04T00:00:00.000Z","tags":[{"inline":true,"label":"C++","permalink":"/blog/tags/c"},{"inline":true,"label":"Design Patterns","permalink":"/blog/tags/design-patterns"}],"readingTime":1.35,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["C++","Design Patterns"]},"unlisted":false,"prevItem":{"title":"\'Singleton\' Design Pattern using simple program","permalink":"/blog/2012/04/06/singleton-design-pattern-using-simple-program"},"nextItem":{"title":"Simple LinkedList program in C++","permalink":"/blog/2012/04/04/linkedlist"}}')},28453:(r,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var e=n(96540);const c={},a=e.createContext(c);function o(r){const t=e.useContext(a);return e.useMemo((function(){return"function"==typeof r?r(t):{...t,...r}}),[t,r])}function s(r){let t;return t=r.disableParentContext?"function"==typeof r.components?r.components(c):r.components||c:o(r.components),e.createElement(a.Provider,{value:t},r.children)}},68061:(r,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>e,toc:()=>u});var e=n(21639),c=n(74848),a=n(28453);const o={tags:["C++","Design Patterns"]},s="\u2018AbstractFactory\u2019 Design Pattern using simple program",i={authorsImageUrls:[]},u=[];function l(r){const t={code:"code",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...r.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(t.p,{children:[(0,c.jsx)(t.strong,{children:"Definition:"})," Provide an interface for creating families of related or dependent objects without specifying their concrete classes."]}),"\n",(0,c.jsx)(t.p,{children:(0,c.jsx)(t.strong,{children:"Program:"})}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-cpp",children:'\r\n#include "iostream"\r\nusing namespace std;\r\n\r\n// Abstract Factory pattern\r\nclass AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show() = 0;\r\n};\r\n\r\nclass AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show() = 0;\r\n};\r\n\r\nclass AbstractFactory\r\n{\r\npublic:\r\n virtual AbstractProductA* CreateProductA() = 0;\r\n virtual AbstractProductB* CreateProductB() = 0;\r\n};\r\n\r\nclass ProductA1 : public AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductA1 Show"<<endl;>\r\n  }\r\n};\r\n\r\nclass ProductB1 : public AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductB1 Show"<<endl;>\r\n  }\r\n};\r\n\r\nclass ProductA2 : public AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductA2 Show"<<endl;\r\n  }\r\n};\r\n\r\nclass ProductB2 : public AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductB2 Show"<<endl;\r\n  }\r\n};\r\n\r\nclass ConcreteFactory1 : public AbstractFactory\r\n{\r\npublic:\r\n    virtual AbstractProductA* CreateProductA()\r\n    {\r\n      return new ProductA1();\r\n    }\r\n\r\n    virtual AbstractProductB* CreateProductB()\r\n    {\r\n      return new ProductB1();\r\n    }\r\n};\r\n\r\nclass ConcreteFactory2 : public AbstractFactory\r\n{\r\npublic:\r\n    virtual AbstractProductA* CreateProductA()\r\n    {\r\n      return new ProductA2();\r\n    }\r\n\r\n    virtual AbstractProductB* CreateProductB()\r\n    {\r\n      return new ProductB2();\r\n    }\r\n};\r\n\r\nclass Client\r\n{\r\nprivate:\r\n  AbstractProductA* _abstractProductA;\r\n  AbstractProductB* _abstractProductB;\r\n\r\npublic:\r\n    Client(AbstractFactory\\* factory)\r\n    {\r\n      _abstractProductB = factory->CreateProductB();\r\n      _abstractProductA = factory->CreateProductA();\r\n    }\r\n\r\n    void Run()\r\n    {\r\n      _abstractProductA->Show();\r\n      _abstractProductB->Show();\r\n\r\n      delete _abstractProductA;\r\n      delete _abstractProductB;\r\n    }\r\n};\r\n\r\nvoid main()\r\n{\r\n  // Abstract factory #1\r\n  AbstractFactory* factory1 = new ConcreteFactory1();\r\n  Client* client1 = new Client(factory1);\r\n  client1->Run();\r\n\r\n  delete factory1;\r\n  delete client1;\r\n\r\n  // Abstract factory #2\r\n  AbstractFactory* factory2 = new ConcreteFactory2();\r\n  Client* client2 = new Client(factory2);\r\n  client2->Run();\r\n\r\n  delete factory2;\r\n  delete client2;\r\n\r\n  getchar();\r\n}\r\n\r\n/*\r\nOUT PUT\r\n-------\r\n\\[ProductA1\\] Show\r\n\\[ProductB1\\] Show\r\n\\[ProductA2\\] Show\r\n\\[ProductB2\\] Show\r\n\\*/\r\n\n'})})]})}function d(r={}){const{wrapper:t}={...(0,a.R)(),...r.components};return t?(0,c.jsx)(t,{...r,children:(0,c.jsx)(l,{...r})}):l(r)}}}]);