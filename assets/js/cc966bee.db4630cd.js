"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[53714],{4150:n=>{n.exports=JSON.parse('{"permalink":"/blog/2012/04/02/queue","source":"@site/blog/2012-04-02-queue.md","title":"Simple Queue program in C++","description":"Definition:","date":"2012-04-02T00:00:00.000Z","tags":[{"inline":true,"label":"Data Structures","permalink":"/blog/tags/data-structures"},{"inline":true,"label":"C++","permalink":"/blog/tags/c"}],"readingTime":0.93,"hasTruncateMarker":false,"authors":[],"frontMatter":{"tags":["Data Structures","C++"]},"unlisted":false,"prevItem":{"title":"\'Builder\' Design Pattern using simple program","permalink":"/blog/2012/04/03/builderdesignpatter"},"nextItem":{"title":"Simple Stack Program in C++","permalink":"/blog/2012/04/02/stack"}}')},28453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>l});var t=r(96540);const i={},s=t.createContext(i);function a(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(s.Provider,{value:e},n.children)}},48239:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>u});var t=r(4150),i=r(74848),s=r(28453);const a={tags:["Data Structures","C++"]},l="Simple Queue program in C++",o={authorsImageUrls:[]},u=[];function c(n){const e={code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Definition:"})}),"\n",(0,i.jsxs)(e.p,{children:["A Queue\xa0is a data structure in which addition of new element takes place at the end called ",(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"rear"})})," of Queue and\xa0deletion of existing element takes place at the other end called ",(0,i.jsx)(e.em,{children:(0,i.jsx)(e.strong,{children:"front"})})," of Queue\xa0."]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Principle:"})}),"\n",(0,i.jsxs)(e.p,{children:["Queue\xa0works on the ",(0,i.jsx)(e.strong,{children:"FIFO"})," \u2013 ",(0,i.jsx)(e.strong,{children:"F"}),"irst\xa0",(0,i.jsx)(e.strong,{children:"I"}),"n ",(0,i.jsx)(e.strong,{children:"F"}),"irst ",(0,i.jsx)(e.strong,{children:"O"}),"ut principle"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include "stdafx.h"\r\n#include "iostream"\r\nusing namespace std;\r\n\r\n#define MAX 10\r\n\r\nclass Queue\r\n{\r\nprivate:\r\n       int arr[MAX];\r\n       int front, rear;\r\n\r\npublic:\r\n      Queue()\r\n      {\r\n            front = -1;\r\n            rear  = -1;\r\n\r\n      }\r\n\r\n       void Add(int item)\r\n      {\r\n             if(rear == MAX-1)\r\n            {\r\n                  cout<<endl<< "Queue is full";\r\n                   return;\r\n            }\r\n\r\n            rear++;\r\n            arr[rear] = item;\r\n\r\n             if( front == -1 )\r\n                  front = 0;\r\n      }\r\n\r\n       int Delete()\r\n      {\r\n             if(front == -1)\r\n            {\r\n                  cout<<endl<< "Queue is empty";\r\n                   return NULL;\r\n            }\r\n\r\n        int data = arr[front];\r\n\r\n             if( front == rear)\r\n                  front = rear = -1;\r\n             else\r\n                  front++;\r\n\r\n             return data;\r\n      }\r\n};\r\n\r\nint main()\r\n{\r\n      Queue q;\r\n\r\n      q.Add(1);\r\n      q.Add(2);\r\n      q.Add(3);\r\n\r\n       int i = q.Delete();\r\n      cout<<endl<< "item="" deleted="<<i<<endl;\r\n\r\n      i = q.Delete();\r\n      cout<<endl<< "Item deleted = "<<i<<endl;\r\n\r\n       return 0;\r\n}\r\n\r\n/*\r\nOUTPUT\r\n----------------\r\nItem deleted = 1\r\n\r\nItem deleted = 2\r\n*/\n'})})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}}}]);