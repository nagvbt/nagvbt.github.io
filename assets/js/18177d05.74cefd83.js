"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["72026"],{77380:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>l,default:()=>h,toc:()=>d,metadata:()=>a,assets:()=>c,contentTitle:()=>t});var a=JSON.parse('{"id":"Languages/Interfaces","title":"Interface","description":"Definition","source":"@site/docs/Languages/Interfaces.md","sourceDirName":"Languages","slug":"/Languages/Interfaces","permalink":"/docs/Languages/Interfaces","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16},"sidebar":"tutorialSidebar","previous":{"title":"Enum","permalink":"/docs/Languages/Enum"},"next":{"title":"Exceptions","permalink":"/docs/Languages/Exceptions"}}'),s=r(85893),i=r(50065);let l={sidebar_position:16},t="Interface",c={},d=[{value:"Definition",id:"definition",level:2},{value:"Syntax",id:"syntax",level:2},{value:"C#",id:"c",level:3},{value:"Example",id:"example",level:3},{value:"Java",id:"java",level:3},{value:"Example",id:"example-1",level:3},{value:"Python",id:"python",level:3},{value:"Example",id:"example-2",level:3},{value:"JavaScript (ES6+)",id:"javascript-es6",level:3},{value:"Example",id:"example-3",level:3},{value:"C++",id:"c-1",level:3},{value:"Example",id:"example-4",level:3},{value:"TypeScript",id:"typescript",level:3},{value:"Example",id:"example-5",level:3}];function o(e){let n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"interface",children:"Interface"})}),"\n",(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.strong,{children:"interface"})," is a contract that specifies a set of methods (and sometimes properties) that\r\nimplementing classes must provide. It defines ",(0,s.jsx)(n.em,{children:"what"})," a class must do, but not ",(0,s.jsx)(n.em,{children:"how"})," it does it."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.strong,{children:"C#"})," and ",(0,s.jsx)(n.strong,{children:"Java"}),", interfaces are explicit language constructs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Python"})," uses abstract base classes (ABC) to simulate interfaces, as it has no built-in interface keyword."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JavaScript"})," doesn\u2019t have interfaces natively but simulates them via base classes and method stubs throwing errors."]}),"\n",(0,s.jsxs)(n.li,{children:["In ",(0,s.jsx)(n.strong,{children:"C++"}),", interfaces are simulated using ",(0,s.jsx)(n.strong,{children:"pure abstract classes"})," (classes with all pure virtual functions)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"c",children:"C#"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"interface className {\r\n    void methodName();  // method signature\r\n}\r\n\r\nclass DerivedClass : className {\r\n    public void methodName() {\r\n        // method implementation\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'using System;\r\n\r\ninterface IDrawable {\r\n    void draw();  // Interface method signature\r\n}\r\n\r\nclass Circle : IDrawable {\r\n    public void draw() {\r\n        Console.WriteLine("Drawing a Circle");\r\n    }\r\n}\r\n\r\nclass Program {\r\n    static void Main() {\r\n        IDrawable drawable = new Circle();\r\n        drawable.draw();  // Output: Drawing a Circle\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"java",children:"Java"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"interface className {\r\n    void methodName();  // method signature\r\n}\r\n\r\nclass DerivedClass implements className {\r\n    public void methodName() {\r\n        // method implementation\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'interface Drawable {\r\n    void draw();  // Interface method signature\r\n}\r\n\r\nclass Circle implements Drawable {\r\n    @Override\r\n    public void draw() {\r\n        System.out.println("Drawing a Circle");\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Drawable drawable = new Circle();\r\n        drawable.draw();  // Output: Drawing a Circle\r\n    }\r\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from abc import ABC, abstractmethod\r\n\r\nclass className(ABC):\r\n    @abstractmethod\r\n    def methodName(self):\r\n        pass\r\n\r\nclass DerivedClass(className):\r\n    def methodName(self):\r\n        # method implementation\r\n        pass\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\r\n\r\nclass Drawable(ABC):\r\n    @abstractmethod\r\n    def draw(self):\r\n        pass\r\n\r\nclass Circle(Drawable):\r\n    def draw(self):\r\n        print("Drawing a Circle")\r\n\r\ncircle = Circle()\r\ncircle.draw()  # Output: Drawing a Circle\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"javascript-es6",children:"JavaScript (ES6+)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class className {\r\n    methodName() {\r\n        throw new Error(\"Method 'methodName' must be implemented.\");\r\n    }\r\n}\r\n\r\nclass DerivedClass extends className {\r\n    methodName() {\r\n        // method implementation\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class Drawable {\r\n    draw() {\r\n        throw new Error("Method \'draw()\' must be implemented.");\r\n    }\r\n}\r\n\r\nclass Circle extends Drawable {\r\n    draw() {\r\n        console.log("Drawing a Circle");\r\n    }\r\n}\r\n\r\nconst circle = new Circle();\r\ncircle.draw();  // Output: Drawing a Circle\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"c-1",children:"C++"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),"\r\nC++ has no explicit ",(0,s.jsx)(n.code,{children:"interface"})," keyword. Interfaces are simulated by creating ",(0,s.jsx)(n.strong,{children:"pure abstract classes"})," \u2014 classes with only pure virtual functions (functions declared with ",(0,s.jsx)(n.code,{children:"= 0"}),") and no data members."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"class className {\r\npublic:\r\n    virtual void methodName() = 0;  // pure virtual function (interface method)\r\n};\r\n\r\nclass DerivedClass : public className {\r\npublic:\r\n    void methodName() override {\r\n        // method implementation\r\n    }\r\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\r\nusing namespace std;\r\n\r\nclass Drawable {\r\npublic:\r\n    virtual void draw() = 0;  // pure virtual function \u2014 interface method\r\n};\r\n\r\nclass Circle : public Drawable {\r\npublic:\r\n    void draw() override {\r\n        cout << "Drawing a Circle" << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Drawable* drawable = new Circle();\r\n    drawable->draw();  // Output: Drawing a Circle\r\n    delete drawable;\r\n    return 0;\r\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"typescript",children:"TypeScript"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),"\r\nTypeScript has explicit ",(0,s.jsx)(n.code,{children:"interface"})," support, allowing you to define the shape of objects and enforce method implementations."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface className {\r\n    methodName(): void;  // interface method\r\n}\r\n\r\nclass DerivedClass implements className {\r\n    methodName(): void {\r\n        // method implementation\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-5",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'interface Drawable {\r\n    draw(): void;  // interface method\r\n}\r\n\r\nclass Circle implements Drawable {\r\n    draw(): void {\r\n        console.log("Drawing a Circle");\r\n    }\r\n}\r\n\r\nconst drawable: Drawable = new Circle();\r\ndrawable.draw();  // Output: Drawing a Circle\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"#interfaces",children:"Back to top"})})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},50065:function(e,n,r){r.d(n,{Z:()=>t,a:()=>l});var a=r(67294);let s={},i=a.createContext(s);function l(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);