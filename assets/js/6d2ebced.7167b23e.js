"use strict";(self.webpackChunkNBT=self.webpackChunkNBT||[]).push([["18271"],{50065:function(n,e,t){t.d(e,{Z:()=>p,a:()=>o});var r=t(67294);let d={},i=r.createContext(d);function o(n){let e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function p(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:o(n.components),r.createElement(i.Provider,{value:e},n.children)}},83260:function(n,e,t){t.r(e),t.d(e,{frontMatter:()=>o,default:()=>u,contentTitle:()=>p,assets:()=>s,toc:()=>a,metadata:()=>r});var r=JSON.parse('{"id":"Cpp/DataStructures/LinkedList","title":"Linked List","description":"","source":"@site/docs/Cpp/DataStructures/LinkedList.md","sourceDirName":"Cpp/DataStructures","slug":"/Cpp/DataStructures/LinkedList","permalink":"/docs/Cpp/DataStructures/LinkedList","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"Cpp","previous":{"title":"Doubly Linked List","permalink":"/docs/Cpp/DataStructures/DoublyLinkedList"},"next":{"title":"Queue","permalink":"/docs/Cpp/DataStructures/Queue"}}'),d=t(85893),i=t(50065);let o={},p="Linked List",s={},a=[];function m(n){let e={code:"code",h1:"h1",header:"header",pre:"pre",...(0,i.a)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(e.header,{children:(0,d.jsx)(e.h1,{id:"linked-list",children:"Linked List"})}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-cpp",children:'#include "iostream"\r\nusing namespace std;\r\n\r\n\r\nclass nextList\r\n{\r\nprivate:\r\n struct Node\r\n {\r\n  int data;\r\n  Node* next;\r\n }*pHead;\r\n\r\npublic:\r\n nextList() { pHead = NULL; }\r\n ~nextList();\r\n\r\n void Print();         // Prints the contents of nextedlist\r\n void Append(int num); // Adds a new Node at the end of the nextedlist\r\n void Delete(int num); // Deletes the specified Node from the nextedlist\r\n\r\n void AddatBeg(int num);// Adds a new Node at the beginning of the nextedlist\r\n void AddAfter(int c, int num); // Adds a new Node after specified number of Nodes\r\n int Count();          // Counts number of Nodes present in the nextedlist\r\n\r\n\r\n};\r\n\r\nvoid main()\r\n{\r\n nextList* pobj = new nextList();\r\n pobj->Append(11);\r\n pobj->Append(22);\r\n pobj->Append(33);\r\n pobj->Delete(33);\r\n pobj->AddatBeg(44);\r\n pobj->AddAfter(1, 55);\r\n pobj->Print();\r\n cout << endl << "No. of elements in nexted list = " << pobj->Count() << endl;\r\n\r\n delete pobj;\r\n}\r\n\r\n/*\r\nOUTPUT\r\n----------------\r\n44\r\n11\r\n55\r\n22\r\n\r\nNo. of elements in nexted list = 4\r\n*/\r\n\r\nnextList::~nextList()\r\n{\r\n if (pHead == NULL)\r\n  return;\r\n\r\n Node* tmp;\r\n while (pHead != NULL)\r\n {\r\n  tmp = pHead->next;\r\n  delete pHead;\r\n  pHead = tmp;\r\n }\r\n}\r\n\r\n// Prints the contents of nextedlist\r\nvoid nextList::Print()\r\n{\r\n if (pHead == NULL)\r\n {\r\n  cout << "EMPTY";\r\n  return;\r\n }\r\n\r\n //Traverse\r\n Node* tmp = pHead;\r\n while (tmp != NULL)\r\n {\r\n  cout << tmp->data << endl;\r\n  tmp = tmp->next;\r\n }\r\n}\r\n\r\n// Adds a new Node at the end of the nextedlist\r\nvoid nextList::Append(int num)\r\n{\r\n Node* newNode;\r\n\r\n newNode = new Node;\r\n newNode->data = num;\r\n newNode->next = NULL;\r\n\r\n if (pHead == NULL)\r\n {\r\n  //create first Node\r\n  pHead = newNode;\r\n }\r\n else\r\n {\r\n  //Traverse\r\n  Node* tmp = pHead;\r\n  while (tmp->next != NULL)\r\n  {\r\n   tmp = tmp->next;\r\n  }\r\n\r\n  //add Node to the end  \r\n  tmp->next = newNode;\r\n }\r\n}\r\n\r\n// Deletes the specified Node from the nextedlist\r\nvoid nextList::Delete(int num)\r\n{\r\n Node* tmp;\r\n\r\n tmp = pHead;\r\n //If Node to be delete is first Node\r\n if (tmp->data == num)\r\n {\r\n  pHead = tmp->next;\r\n  delete tmp;\r\n  return;\r\n }\r\n\r\n // traverse list till the last but one Node is reached\r\n Node* tmp2 = tmp;\r\n while (tmp != NULL)\r\n {\r\n  if (tmp->data == num)\r\n  {\r\n   tmp2->next = tmp->next;\r\n   delete tmp;\r\n   return;\r\n  }\r\n\r\n  tmp2 = tmp;\r\n  tmp = tmp->next;\r\n }\r\n cout << "\\nElement " << num << " not Found.";\r\n}\r\n\r\n// Adds a new Node at the beginning of the nextedlist\r\nvoid nextList::AddatBeg(int num)\r\n{\r\n Node* tmp;\r\n\r\n //add new Node\r\n tmp = new Node;\r\n tmp->data = num;\r\n tmp->next = pHead;\r\n pHead = tmp;\r\n}\r\n\r\n//Adds a new Node after specified number of Nodes\r\nvoid nextList::AddAfter(int c, int num)\r\n{\r\n Node* tmp;\r\n Node* tmp2;\r\n int i;\r\n //Skip to the desired portion\r\n for (i = 0, tmp = pHead; i < c; i++)\r\n {\r\n  tmp = tmp->next;\r\n\r\n  //if end of nexted list is enCountered\r\n  if (tmp == NULL)\r\n  {\r\n   cout << endl << "There are less than " << c << " elements";\r\n   return;\r\n  }\r\n }\r\n\r\n //insert new Node\r\n tmp2 = new Node;\r\n tmp2->data = num;\r\n tmp2->next = tmp->next;\r\n tmp->next = tmp2;\r\n}\r\n\r\n// Counts number of Nodes present in the nextedlist\r\nint nextList::Count()\r\n{\r\n Node* tmp;\r\n int c = 0;\r\n\r\n //Traverse the entire nexted List\r\n for (tmp = pHead; tmp != NULL; tmp = tmp->next)\r\n  c++;\r\n\r\n return (c);\r\n}\r\n\n'})})]})}function u(n={}){let{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(m,{...n})}):m(n)}}}]);