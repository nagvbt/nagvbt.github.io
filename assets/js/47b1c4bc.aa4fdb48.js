"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[22791],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(a),h=i,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||s;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var c=2;c<s;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},44894:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const s={sidebar_position:6},o="Type Casting and others",r={unversionedId:"articles/Cpp/TypeCastingOthers",id:"articles/Cpp/TypeCastingOthers",title:"Type Casting and others",description:"Type Casting",source:"@site/docs/articles/Cpp/TypeCastingOthers.md",sourceDirName:"articles/Cpp",slug:"/articles/Cpp/TypeCastingOthers",permalink:"/docs/articles/Cpp/TypeCastingOthers",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Templates and Exception Handling",permalink:"/docs/articles/Cpp/Templates"},next:{title:"Calculate Salary",permalink:"/docs/articles/Cpp/CalculateSalary"}},l={},c=[{value:"Type Casting",id:"type-casting",level:2},{value:"1.What is Type Casting ?",id:"1what-is-type-casting-",level:3},{value:"2.What are the different types of Type Casting ?",id:"2what-are-the-different-types-of-type-casting-",level:3},{value:"3.Explain about Implicit Type Casting ?",id:"3explain-about-implicit-type-casting-",level:3},{value:"4.Explain about Explicit Type Casting ?",id:"4explain-about-explicit-type-casting-",level:3},{value:"5.What is dynamic_cast ?",id:"5what-is-dynamic_cast-",level:3},{value:"6.What is static_cast ?",id:"6what-is-static_cast-",level:3},{value:"7.What is const_cast ?",id:"7what-is-const_cast-",level:3},{value:"8.What is reinterpret_cast ?",id:"8what-is-reinterpret_cast-",level:3},{value:"9.What is up casting and down casting ?",id:"9what-is-up-casting-and-down-casting-",level:3},{value:"Other Features",id:"other-features",level:2},{value:"1.What is Run Time Type ID (RTTI) ?",id:"1what-is-run-time-type-id-rtti-",level:3},{value:"2.What is the syntax for RTTI ?",id:"2what-is-the-syntax-for-rtti-",level:3},{value:"3.Why size of an empty C++ class not zero?",id:"3why-size-of-an-empty-c-class-not-zero",level:3},{value:"4.What is the size of a class with one virtual function ?",id:"4what-is-the-size-of-a-class-with-one-virtual-function-",level:3},{value:"5.What is the size of a class with more than one virtual function ?",id:"5what-is-the-size-of-a-class-with-more-than-one-virtual-function-",level:3},{value:"6.What is the size of a class with three intiger values ?",id:"6what-is-the-size-of-a-class-with-three-intiger-values-",level:3},{value:"7.What are the differences between malloc and new ?",id:"7what-are-the-differences-between-malloc-and-new-",level:3},{value:"8.What are the differences between free and delete ?",id:"8what-are-the-differences-between-free-and-delete-",level:3},{value:"9.Define namespace ?",id:"9define-namespace-",level:3},{value:"10.How to call a static member outside a class ?",id:"10how-to-call-a-static-member-outside-a-class-",level:3},{value:"11.When should I use const function ?",id:"11when-should-i-use-const-function-",level:3},{value:"12.Can I modify attributes in a const method ?",id:"12can-i-modify-attributes-in-a-const-method-",level:3},{value:"13.How do I specify a pointer to a static method ?",id:"13how-do-i-specify-a-pointer-to-a-static-method-",level:3},{value:"14.How do I write the code for methods outside classes?",id:"14how-do-i-write-the-code-for-methods-outside-classes",level:3},{value:"15.How to initialize a const member variable?",id:"15how-to-initialize-a-const-member-variable",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"type-casting-and-others"},"Type Casting and others"),(0,i.kt)("h2",{id:"type-casting"},"Type Casting"),(0,i.kt)("h3",{id:"1what-is-type-casting-"},"1.What is Type Casting ?"),(0,i.kt)("p",null,"Converting an expression of a given type into another type is known as type-casting."),(0,i.kt)("h3",{id:"2what-are-the-different-types-of-type-casting-"},"2.What are the different types of Type Casting ?"),(0,i.kt)("p",null,"Two types\tImplicit Type Casting and Explicit Type Casting"),(0,i.kt)("h3",{id:"3explain-about-implicit-type-casting-"},"3.Explain about Implicit Type Casting ?"),(0,i.kt)("p",null,"Implicit conversions do not require any operator. They are automatically performed when a value is copied to a compatible type. Some of these conversions may imply a loss of precision, which can be avoided by explicit conversion."),(0,i.kt)("p",null,"e.g: (short to int, int to float, double to int...)"),(0,i.kt)("h3",{id:"4explain-about-explicit-type-casting-"},"4.Explain about Explicit Type Casting ?"),(0,i.kt)("p",null,"Many conversions, especially those that imply a different interpretation of the value, require an explicit conversion. "),(0,i.kt)("p",null,"In order to control these types of conversions between classes, we have four specific casting operators: dynamic_cast, reinterpret_cast, static_cast and const_cast."),(0,i.kt)("h3",{id:"5what-is-dynamic_cast-"},"5.What is dynamic_cast ?"),(0,i.kt)("p",null,"dynamic_cast Used for conversion of polymorphic types."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"dynamic_cast <new_type> (expression)\n")),(0,i.kt)("h3",{id:"6what-is-static_cast-"},"6.What is static_cast ?"),(0,i.kt)("p",null,"static_cast Used for conversion of nonpolymorphic types."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"static_cast <new_type> (expression)\n")),(0,i.kt)("h3",{id:"7what-is-const_cast-"},"7.What is const_cast ?"),(0,i.kt)("p",null,"const_cast Used to remove or set the const, volatile attributes."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const_cast <new_type> (expression)\n")),(0,i.kt)("h3",{id:"8what-is-reinterpret_cast-"},"8.What is reinterpret_cast ?"),(0,i.kt)("p",null,"reinterpret_cast Used for simple reinterpretation of bits."),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"reinterpret_cast <new_type> (expression)\n")),(0,i.kt)("h3",{id:"9what-is-up-casting-and-down-casting-"},"9.What is up casting and down casting ?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Downcasting:"))," dynamic_cast that performs this conversion. Downcasting is the opposite of the basic object-oriented rule, which states objects of a derived class, can always be assigned to variables of a base class."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"Upcasting:"))," An object can be used as its own type or as an object of its base type. In addition it can be manipulated through an address of the base type. Taking the address of an object (either a pointer or a reference) and treating it as the address of the base type is called upcasting because of the way inheritance trees are drawn with the base of the class at the top."),(0,i.kt)("h2",{id:"other-features"},"Other Features"),(0,i.kt)("h3",{id:"1what-is-run-time-type-id-rtti-"},"1.What is Run Time Type ID (RTTI) ?"),(0,i.kt)("p",null,"Sometimes the types of an object is unknown at compile time, since base class pointers may be used to point to objects of the base class or any object derived from that base."),(0,i.kt)("p",null," It is always not possible to know in advance what type of object will be pointed to by a base pointer at any given moment of time. This determination must be made at runtime, using RTTI."),(0,i.kt)("h3",{id:"2what-is-the-syntax-for-rtti-"},"2.What is the syntax for RTTI ?"),(0,i.kt)("p",null,"Syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <typeinfo>\n\ntypeid(i).name() -> Returns the type of value of object\nif(typeid(value1) == typeid(value1))\n{\n    //Do some thing\n}\n")),(0,i.kt)("h3",{id:"3why-size-of-an-empty-c-class-not-zero"},"3.Why size of an empty C++ class not zero?"),(0,i.kt)("p",null,"To ensure that the addresses of two different objects will be different C++ compiler will allocate one byte of memory."),(0,i.kt)("h3",{id:"4what-is-the-size-of-a-class-with-one-virtual-function-"},"4.What is the size of a class with one virtual function ?"),(0,i.kt)("p",null,"4 Bytes to store the virtual table pointer."),(0,i.kt)("h3",{id:"5what-is-the-size-of-a-class-with-more-than-one-virtual-function-"},"5.What is the size of a class with more than one virtual function ?"),(0,i.kt)("p",null,"4 Bytes to store the virtual table pointer."),(0,i.kt)("h3",{id:"6what-is-the-size-of-a-class-with-three-intiger-values-"},"6.What is the size of a class with three intiger values ?"),(0,i.kt)("p",null,"As integer takes 4 bytes. Size will be 3 x 4 bytes = 12 bytes."),(0,i.kt)("h3",{id:"7what-are-the-differences-between-malloc-and-new-"},"7.What are the differences between malloc and new ?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"malloc:"))," "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Allocates memory only "),(0,i.kt)("li",{parentName:"ol"},"Does not Calls objects constructor "),(0,i.kt)("li",{parentName:"ol"},"No Type Safety malloc returns void*, so it requires a cast. "),(0,i.kt)("li",{parentName:"ol"},"Cannot be overloaded\n")),(0,i.kt)("p",null,"new: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Allocates right amount of memory for an object "),(0,i.kt)("li",{parentName:"ol"},"Calls objects constructor "),(0,i.kt)("li",{parentName:"ol"},"Provides Type Safety (avoids to assign the resulting pointer to an incompatible pointer type) "),(0,i.kt)("li",{parentName:"ol"},"New operator can be overloaded by a class thus providing flexibility.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int *p1 = (int*)malloc(sizeof(int));\nSample *p2 = (Sample*)malloc(sizeof(Sample));\nSample *p3 = new Sample();\n")),(0,i.kt)("h3",{id:"8what-are-the-differences-between-free-and-delete-"},"8.What are the differences between free and delete ?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"free:"))," Deallocates memory only\t\t\t",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"delete:"))," Calls the object destructor and then deallocates memory"),(0,i.kt)("h3",{id:"9define-namespace-"},"9.Define namespace ?"),(0,i.kt)("p",null,"Namespace allow to code different entities without bothering about name clashes. A namespace is a logical entity of code. A namespace can be included into another namespace."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"namespace name1\n{\n    void fun1() { /* ... */ }\n    namespace name2\n    {\n        void fun2() { /* ... */ }\n    }\n}\n")),(0,i.kt)("h3",{id:"10how-to-call-a-static-member-outside-a-class-"},"10.How to call a static member outside a class ?"),(0,i.kt)("p",null,"By using :: operator we can call/access static members "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class A\n{\n    static int count;\n    static int Getcount() { return count++; }\n};\n\nint function()\n{\n    A::id = 0; // call to a static attribute\n    return A::gendId(); // call to a static method         \n}\n")),(0,i.kt)("h3",{id:"11when-should-i-use-const-function-"},"11.When should I use const function ?"),(0,i.kt)("p",null,"constant function cannot modify any data members or call any member functions that aren't declared as constant "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class A\n{\n    int id;\n    void setid(int i) const\n    {\n        id = i // error. setid shouldn't modify\n    }\n};\n")),(0,i.kt)("h3",{id:"12can-i-modify-attributes-in-a-const-method-"},"12.Can I modify attributes in a const method ?"),(0,i.kt)("p",null,"Yes. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Employee\n{\n    int id;\n    mutable int sal;\n    void f() const\n    {\n        id = 101; // error\n        sal = 600; // ok\n    }\n};\n")),(0,i.kt)("h3",{id:"13how-do-i-specify-a-pointer-to-a-static-method-"},"13.How do I specify a pointer to a static method ?"),(0,i.kt)("p",null,"Below Program demonstrates how to specify a pointer to a static method "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class A\n{\n    static int id;\n    static void setid(int i) { id = i; }\n};\nvoid function()\n{\n    void (*psetid)(int) = A::setid; // assignment\n    void (*psetid)(int) = &A::setid; // alternative\n    (*psetid)(2); // calling the method with parameter value 2.\n}\n")),(0,i.kt)("h3",{id:"14how-do-i-write-the-code-for-methods-outside-classes"},"14.How do I write the code for methods outside classes?"),(0,i.kt)("p",null,"Below Program demonstrates how to write the code for methods outside classes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class A \n{\n    int id;\n    getid();\n};\nA::getid()\n{\n    return id;\n}\n")),(0,i.kt)("h3",{id:"15how-to-initialize-a-const-member-variable"},"15.How to initialize a const member variable?"),(0,i.kt)("p",null,"As the value of a const member cannot be assigned with operator =, its value must be initialized as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class A\n{\n    const int id;\n    A(int i): id(i) {} //  member variable id is initialized to the value of parameter i\n};\n")))}u.isMDXComponent=!0}}]);