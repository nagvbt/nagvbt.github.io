"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[86661],{34489:(r,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var e=n(85893),c=n(11151);const a={tags:["C++","Design Patterns"]},o="\u2018AbstractFactory\u2019 Design Pattern using simple program",s={permalink:"/blog/2012/04/04/abstractfactory-designpatter",source:"@site/blog/2012-04-04-abstractfactory-designpatter.md",title:"\u2018AbstractFactory\u2019 Design Pattern using simple program",description:"Definition: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.",date:"2012-04-04T00:00:00.000Z",formattedDate:"April 4, 2012",tags:[{label:"C++",permalink:"/blog/tags/c"},{label:"Design Patterns",permalink:"/blog/tags/design-patterns"}],readingTime:1.35,hasTruncateMarker:!1,authors:[],frontMatter:{tags:["C++","Design Patterns"]},unlisted:!1,prevItem:{title:"'Singleton' Design Pattern using simple program",permalink:"/blog/2012/04/06/singleton-design-pattern-using-simple-program"},nextItem:{title:"Simple LinkedList program in C++",permalink:"/blog/2012/04/04/linkedlist"}},i={authorsImageUrls:[]},u=[];function l(r){const t={code:"code",p:"p",pre:"pre",strong:"strong",...(0,c.a)(),...r.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:"Definition:"})," Provide an interface for creating families of related or dependent objects without specifying their concrete classes."]}),"\n",(0,e.jsx)(t.p,{children:(0,e.jsx)(t.strong,{children:"Program:"})}),"\n",(0,e.jsx)(t.pre,{children:(0,e.jsx)(t.code,{className:"language-cpp",children:'\r\n#include "iostream"\r\nusing namespace std;\r\n\r\n// Abstract Factory pattern\r\nclass AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show() = 0;\r\n};\r\n\r\nclass AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show() = 0;\r\n};\r\n\r\nclass AbstractFactory\r\n{\r\npublic:\r\n virtual AbstractProductA* CreateProductA() = 0;\r\n virtual AbstractProductB* CreateProductB() = 0;\r\n};\r\n\r\nclass ProductA1 : public AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductA1 Show"<<endl;>\r\n  }\r\n};\r\n\r\nclass ProductB1 : public AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductB1 Show"<<endl;>\r\n  }\r\n};\r\n\r\nclass ProductA2 : public AbstractProductA\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductA2 Show"<<endl;\r\n  }\r\n};\r\n\r\nclass ProductB2 : public AbstractProductB\r\n{\r\npublic:\r\n  virtual void Show()\r\n  {\r\n    cout<<"ProductB2 Show"<<endl;\r\n  }\r\n};\r\n\r\nclass ConcreteFactory1 : public AbstractFactory\r\n{\r\npublic:\r\n    virtual AbstractProductA* CreateProductA()\r\n    {\r\n      return new ProductA1();\r\n    }\r\n\r\n    virtual AbstractProductB* CreateProductB()\r\n    {\r\n      return new ProductB1();\r\n    }\r\n};\r\n\r\nclass ConcreteFactory2 : public AbstractFactory\r\n{\r\npublic:\r\n    virtual AbstractProductA* CreateProductA()\r\n    {\r\n      return new ProductA2();\r\n    }\r\n\r\n    virtual AbstractProductB* CreateProductB()\r\n    {\r\n      return new ProductB2();\r\n    }\r\n};\r\n\r\nclass Client\r\n{\r\nprivate:\r\n  AbstractProductA* _abstractProductA;\r\n  AbstractProductB* _abstractProductB;\r\n\r\npublic:\r\n    Client(AbstractFactory\\* factory)\r\n    {\r\n      _abstractProductB = factory->CreateProductB();\r\n      _abstractProductA = factory->CreateProductA();\r\n    }\r\n\r\n    void Run()\r\n    {\r\n      _abstractProductA->Show();\r\n      _abstractProductB->Show();\r\n\r\n      delete _abstractProductA;\r\n      delete _abstractProductB;\r\n    }\r\n};\r\n\r\nvoid main()\r\n{\r\n  // Abstract factory #1\r\n  AbstractFactory* factory1 = new ConcreteFactory1();\r\n  Client* client1 = new Client(factory1);\r\n  client1->Run();\r\n\r\n  delete factory1;\r\n  delete client1;\r\n\r\n  // Abstract factory #2\r\n  AbstractFactory* factory2 = new ConcreteFactory2();\r\n  Client* client2 = new Client(factory2);\r\n  client2->Run();\r\n\r\n  delete factory2;\r\n  delete client2;\r\n\r\n  getchar();\r\n}\r\n\r\n/*\r\nOUT PUT\r\n-------\r\n\\[ProductA1\\] Show\r\n\\[ProductB1\\] Show\r\n\\[ProductA2\\] Show\r\n\\[ProductB2\\] Show\r\n\\*/\r\n\n'})})]})}function d(r={}){const{wrapper:t}={...(0,c.a)(),...r.components};return t?(0,e.jsx)(t,{...r,children:(0,e.jsx)(l,{...r})}):l(r)}},11151:(r,t,n)=>{n.d(t,{Z:()=>s,a:()=>o});var e=n(67294);const c={},a=e.createContext(c);function o(r){const t=e.useContext(a);return e.useMemo((function(){return"function"==typeof r?r(t):{...t,...r}}),[t,r])}function s(r){let t;return t=r.disableParentContext?"function"==typeof r.components?r.components(c):r.components||c:o(r.components),e.createElement(a.Provider,{value:t},r.children)}}}]);