"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[36930],{3905:(n,e,t)=>{t.d(e,{Zo:()=>p,kt:()=>L});var r=t(67294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function l(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var d=r.createContext({}),u=function(n){var e=r.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):l(l({},e),n)),t},p=function(n){var e=u(n.components);return r.createElement(d.Provider,{value:e},n.children)},c="mdxType",s={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,d=n.parentName,p=a(n,["components","mdxType","originalType","parentName"]),c=u(t),m=i,L=c["".concat(d,".").concat(m)]||c[m]||s[m]||o;return t?r.createElement(L,l(l({ref:e},p),{},{components:t})):r.createElement(L,l({ref:e},p))}));function L(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,l=new Array(o);l[0]=m;var a={};for(var d in e)hasOwnProperty.call(e,d)&&(a[d]=e[d]);a.originalType=n,a[c]="string"==typeof n?n:i,l[1]=a;for(var u=2;u<o;u++)l[u]=t[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},33569:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>l,default:()=>s,frontMatter:()=>o,metadata:()=>a,toc:()=>u});var r=t(87462),i=(t(67294),t(3905));const o={},l="Doubly Linked List",a={unversionedId:"articles/Cpp/DataStructures/DoublyLinkedList",id:"articles/Cpp/DataStructures/DoublyLinkedList",title:"Doubly Linked List",description:"",source:"@site/docs/articles/Cpp/DataStructures/DoublyLinkedList.md",sourceDirName:"articles/Cpp/DataStructures",slug:"/articles/Cpp/DataStructures/DoublyLinkedList",permalink:"/docs/articles/Cpp/DataStructures/DoublyLinkedList",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Data Structures",permalink:"/docs/articles/Cpp/DataStructures/"},next:{title:"Linked List",permalink:"/docs/articles/Cpp/DataStructures/LinkedList"}},d={},u=[],p={toc:u},c="wrapper";function s(n){let{components:e,...t}=n;return(0,i.kt)(c,(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"doubly-linked-list"},"Doubly Linked List"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'\n#include "iostream"\nusing namespace std;\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n    struct Node *prev;\n}*pHead;\n \n/*\n Class Declaration \n */\nclass DoublyLinkedList\n{\n    public:\n        void Create_list(int value);\n        void Add_atBegin(int value);\n        void Add_After(int value, int position);\n        void Delete(int value);\n        void Search(int value);\n        void Print();\n        void Count();\n        void Reverse();\n        DoublyLinkedList()\n        {\n            pHead = NULL;  \n        }\n};\n \n/*\n * Main: Conatins Menu\n */\nint main()\n{\n    int choice, element, position;\n    DoublyLinkedList dl;\n    while (1)\n    {\n        cout<<endl<<"----------------------------"<<endl;\n        cout<<endl<<"Operations on Doubly nexted list"<<endl;\n        cout<<endl<<"----------------------------"<<endl;         \n        cout<<"1.Create Node"<<endl;\n        cout<<"2.Add at begining"<<endl;\n        cout<<"3.Add after position"<<endl;\n        cout<<"4.Delete"<<endl;\n        cout<<"5.Display"<<endl;\n        cout<<"6.Count"<<endl;\n        cout<<"7.Reverse"<<endl;\n        cout<<"8.Quit"<<endl;\n        cout<<"Enter your choice : ";\n        cin>>choice;\n        switch ( choice )\n        {\n        case 1:\n            cout<<"Enter the element: ";\n            cin>>element;\n            dl.Create_list(element);\n            cout<<endl;\n            break;\n        case 2:\n            cout<<"Enter the element: ";\n            cin>>element;\n            dl.Add_atBegin(element);\n            cout<<endl;\n            break;\n        case 3:\n            cout<<"Enter the element: ";\n            cin>>element;\n            cout<<"Insert Element after postion: ";\n            cin>>position;\n            dl.Add_After(element, position);\n            cout<<endl;\n            break;\n        case 4:\n            if (pHead == NULL)\n            {                      \n                cout<<"List empty,nothing to delete"<<endl;   \n                break;\n            }\n            cout<<"Enter the element for deletion: ";\n            cin>>element;\n            dl.Delete(element);\n            cout<<endl;\n            break;\n        case 5:\n            dl.Print();\n            cout<<endl;\n            break;\n        case 6:\n            dl.Count();\n            break;    \n        case 7:\n            if (pHead == NULL)\n            {\n                cout<<"List empty,nothing to Reverse"<<endl;\n                break;\n            }\n            dl.Reverse();\n            cout<<endl;\n            break;\n        case 8:\n            exit(1);\n        default:\n            cout<<"Wrong choice"<<endl;\n        }\n    }\n    return 0;\n}\n \n/*\n * Create Double next List\n */\nvoid DoublyLinkedList::Create_list(int value)\n{\n    Node *s, *temp;\n    temp = new Node; \n    temp->data = value;\n    temp->next = NULL;\n\n    if (pHead == NULL)\n    {\n        temp->prev = NULL;\n        pHead = temp;\n    }\n    else\n    {\n        s = pHead;\n        while (s->next != NULL)\n  {\n            s = s->next;\n  }\n        s->next = temp;\n        temp->prev = s;\n    }\n}\n \n/*\n * Insertion at the beginning\n */\nvoid DoublyLinkedList::Add_atBegin(int value)\n{\n    if (pHead == NULL)\n    {\n        cout<<"First Create the list."<<endl;\n        return;\n    }\n    Node *temp = new Node;\n temp->prev = NULL;\n    temp->data = value;\n    temp->next = pHead;\n    pHead->prev = temp;\n    pHead = temp;\n    cout<<"Element Inserted"<<endl;\n}\n \n/*\n * Insertion of element at a particular position\n */\nvoid DoublyLinkedList::Add_After(int value, int pos)\n{\n    if (pHead == NULL)\n    {\n        cout<<"First Create the list."<<endl;\n        return;\n    }\n    struct Node *tmp, *q;\n    int i;\n    q = pHead;\n    for (i = 0;i < pos - 1;i++)\n    {\n        q = q->next;\n        if (q == NULL)\n        {\n            cout<<"There are less than ";\n            cout<<pos<<" elements."<<endl;\n            return;\n        }\n    }\n    tmp = new(struct Node);\n    tmp->data = value;\n    if (q->next == NULL)\n    {\n        q->next = tmp;\n        tmp->next = NULL;\n        tmp->prev = q;      \n    }\n    else\n    {\n        tmp->next = q->next;\n        tmp->next->prev = tmp;\n        q->next = tmp;\n        tmp->prev = q;\n    }\n    cout<<"Element Inserted"<<endl;\n}\n \n/*\n * Deletion of element from the list\n */\nvoid DoublyLinkedList::Delete(int value)\n{\n    struct Node *tmp, *q;\n     /*first element deletion*/\n    if (pHead->data == value)\n    {\n        tmp = pHead;\n        pHead = pHead->next;  \n        pHead->prev = NULL;\n        cout<<"Element Deleted"<<endl;\n        free(tmp);\n        return;\n    }\n    q = pHead;\n    while (q->next->next != NULL)\n    {   \n        /*Element deleted in between*/\n        if (q->next->data == value)  \n        {\n            tmp = q->next;\n            q->next = tmp->next;\n            tmp->next->prev = q;\n            cout<<"Element Deleted"<<endl;\n            free(tmp);\n            return;\n        }\n        q = q->next;\n    }\n     /*last element deleted*/\n    if (q->next->data == value)    \n    {  \n        tmp = q->next;\n        free(tmp);\n        q->next = NULL;\n        cout<<"Element Deleted"<<endl;\n        return;\n    }\n    cout<<"Element "<<value<<" not found"<<endl;\n}\n \n/*\n * Display elements of Doubly next List\n */\nvoid DoublyLinkedList::Print()\n{\n    struct Node *q;\n    if (pHead == NULL)\n    {\n        cout<<"List empty,nothing to display"<<endl;\n        return;\n    }\n    q = pHead;\n    cout<<"The Doubly next List is :"<<endl;\n    while (q != NULL)\n    {\n        cout<<q->data<<" <-> ";\n        q = q->next;\n    }\n    cout<<"NULL"<<endl;\n}\n \n/*\n * Number of elements in Doubly next List\n */\nvoid DoublyLinkedList::Count()\n{  \n    struct Node *q = pHead;\n    int cnt = 0;\n    while (q != NULL)\n    {\n        q = q->next;\n        cnt++;\n    }\n    cout<<"Number of elements are: "<<cnt<<endl;\n}\n \n/*\n * Reverse Doubly next List\n */\nvoid DoublyLinkedList::Reverse()\n{\n    struct Node *p1, *p2;\n    p1 = pHead;\n    p2 = p1->next;\n    p1->next = NULL;\n    p1->prev = p2;\n    while (p2 != NULL)arn start\n    {\n        p2->prev = p2->next;\n        p2->next = p1;\n        p1 = p2;\n        p2 = p2->prev; \n    }\n    pHead = p1;\n    cout<<"List Reversed"<<endl; \n}\n')))}s.isMDXComponent=!0}}]);