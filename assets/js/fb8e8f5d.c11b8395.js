"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[14897],{3905:(n,t,e)=>{e.d(t,{Zo:()=>s,kt:()=>f});var i=e(67294);function r(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function o(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function l(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?o(Object(e),!0).forEach((function(t){r(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function p(n,t){if(null==n)return{};var e,i,r=function(n,t){if(null==n)return{};var e,i,r={},o=Object.keys(n);for(i=0;i<o.length;i++)e=o[i],t.indexOf(e)>=0||(r[e]=n[e]);return r}(n,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(i=0;i<o.length;i++)e=o[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(r[e]=n[e])}return r}var a=i.createContext({}),d=function(n){var t=i.useContext(a),e=t;return n&&(e="function"==typeof n?n(t):l(l({},t),n)),e},s=function(n){var t=d(n.components);return i.createElement(a.Provider,{value:t},n.children)},m="mdxType",c={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(n,t){var e=n.components,r=n.mdxType,o=n.originalType,a=n.parentName,s=p(n,["components","mdxType","originalType","parentName"]),m=d(e),u=r,f=m["".concat(a,".").concat(u)]||m[u]||c[u]||o;return e?i.createElement(f,l(l({ref:t},s),{},{components:e})):i.createElement(f,l({ref:t},s))}));function f(n,t){var e=arguments,r=t&&t.mdxType;if("string"==typeof n||r){var o=e.length,l=new Array(o);l[0]=u;var p={};for(var a in t)hasOwnProperty.call(t,a)&&(p[a]=t[a]);p.originalType=n,p[m]="string"==typeof n?n:r,l[1]=p;for(var d=2;d<o;d++)l[d]=e[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,e)}u.displayName="MDXCreateElement"},88407:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>d});var i=e(87462),r=(e(67294),e(3905));const o={title:"Simple LinkedList program in C++",date:"2012-04-04",categories:["c-cpp-mfc-vcpp"],tags:["Data Structures"]},l=void 0,p={permalink:"/blog/2012/04/04/linkedlist",source:"@site/blog/2012-04-04-linkedlist.md",title:"Simple LinkedList program in C++",description:"Definition:",date:"2012-04-04T00:00:00.000Z",formattedDate:"April 4, 2012",tags:[{label:"Data Structures",permalink:"/blog/tags/data-structures"}],readingTime:2.71,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Simple LinkedList program in C++",date:"2012-04-04",categories:["c-cpp-mfc-vcpp"],tags:["Data Structures"]},prevItem:{title:"\u2018AbstractFactory\u2019 Design Pattern using simple program",permalink:"/blog/2012/04/04/abstractfactory-designpatter"},nextItem:{title:"'Builder' Design Pattern using simple program",permalink:"/blog/2012/04/03/builderdesignpatter"}},a={authorsImageUrls:[]},d=[],s={toc:d},m="wrapper";function c(n){let{components:t,...e}=n;return(0,r.kt)(m,(0,i.Z)({},s,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Definition:")),(0,r.kt)("p",null,"A linked list is a data structure that consists of a sequence of data records such that in each record there is a field that contains a reference (i.e., a link) to the next record in the sequence."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include "stdafx.h"\n#include "iostream"\nusing namespace std;\n\nclass LinkList\n{\nprivate:\n      struct Node\n      {\n        int data;\n        Node\\* link;\n      }\\*p;\n\npublic:\n      LinkList();\n      ~LinkList();\n\n       void Print();         // Prints the contents of linkedlist\n       void Append(int num); // Adds a new node at the end of the linkedlist\n       void Delete(int num); // Deletes the specified node from the linkedlist\n\n       void AddatBeg(int num);// Adds a new node at the beginning of the linkedlist\n       void AddAfter(int c, int num); // Adds a new node after specified number of nodes\n       int Count();          // Counts number of nodes present in the linkedlist\n\n};\n\nLinkList::LinkList()\n{\n  p = NULL;\n}\n\nLinkList::~LinkList()\n{\n  if (p == NULL)\n        return;\n\n  Node\\* tmp;\n  while(p != NULL)\n  {\n       tmp = p-&gt;link ;\n     delete p;\n       p = tmp;\n  }\n}\n\n// Prints the contents of linkedlist\nvoid LinkList::Print()\n{\n  if (p == NULL)\n  {\n        cout&lt;&lt; "EMPTY";\n        return;\n  }\n\n  //Traverse\n  Node\\* tmp = p;\n  while(tmp != NULL)\n  {\n       cout&lt;data&lt;&lt;endl;\n       tmp = tmp-&gt;link ;\n  }\n}\n\n// Adds a new node at the end of the linkedlist\nvoid LinkList::Append(int num)\n{\n      Node \\*newNode;\n\n      newNode = new Node;\n      newNode-&gt;data = num;\n      newNode-&gt;link = NULL;\n\n       if(p == NULL)\n      {\n       //create first node\n         p = newNode;\n      }\n       else\n      {\n             //Traverse\n            Node \\*tmp = p;\n             while(tmp-&gt;link != NULL)\n            {\n                  tmp = tmp-&gt;link;\n            }\n\n             //add node to the end\n        tmp-&gt;link = newNode;\n      }\n}\n\n// Deletes the specified node from the linkedlist\nvoid LinkList::Delete( int num )\n{\n   Node \\*tmp;\n\n   tmp = p;\n   //If node to be delete is first node\n   if( tmp-&gt;data == num )\n   {\n      p = tmp-&gt;link;\n      delete tmp;\n      return;\n   }\n\n   // traverse list till the last but one node is reached\n   Node \\*tmp2 = tmp;\n   while( tmp!=NULL )\n   {\n      if( tmp-&gt;data == num )\n      {\n         tmp2-&gt;link = tmp-&gt;link;\n         delete tmp;\n         return;\n      }\n\n      tmp2 = tmp;\n      tmp = tmp-&gt;link;\n   }\n   cout&lt;&lt; "nElement "&lt;&lt;num&lt;&lt;" not Found." ;\n}\n\n// Adds a new node at the beginning of the linkedlist\nvoid LinkList::AddatBeg(int num)\n{\n      Node \\*tmp;\n\n       //add new node\n      tmp = new Node;\n      tmp-&gt;data = num;\n      tmp-&gt;link = p;\n      p = tmp;\n}\n\n//Adds a new node after specified number of nodes\nvoid LinkList::AddAfter(int c, int num)\n{\n      Node \\*tmp;\n      Node \\*tmp2;\n       int i;\n       //Skip to the desired portion\n       for( i = 0, tmp = p; i\n      {\n            tmp = tmp-&gt;link;\n\n             //if end of linked list is encountered\n             if(tmp == NULL)\n            {\n                  cout&lt;&lt;endl&lt;&lt; "There are less than "&lt;&lt;c&lt;&lt;" elements" ;\n                   return;\n            }\n      }\n\n       //insert new node\n      tmp2 = new Node;\n      tmp2-&gt;data = num;\n      tmp2-&gt;link = tmp-&gt;link;\n      tmp-&gt;link = tmp2;\n}\n\n// Counts number of nodes present in the linkedlist\nint LinkList::Count()\n{\n      Node \\*tmp;\n       int c = 0;\n\n       //Traverse the entire Linked List\n       for (tmp = p; tmp != NULL; tmp = tmp-&gt;link)\n            c++;\n\n       return (c);\n}\n\nvoid main()\n{\n      LinkList\\* pobj = new LinkList();\n      pobj-&gt;Append(11);\n      pobj-&gt;Append(22);\n      pobj-&gt;Append(33);\n      pobj-&gt;Delete(33);\n      pobj-&gt;AddatBeg(44);\n      pobj-&gt;AddAfter(1, 55);\n      pobj-&gt;Print();\n      cout&lt;&lt;endl&lt;&lt; "no.="" of="" elements="" in="" linked="" list="&lt;&lt;pobj-&gt;Count()&lt;&lt;&lt;span class=" hiddenspellerror"="" pre=""&gt;endl;\n\n       delete pobj;\n}\n\n/\\*\nOUTPUT\n----------------\n44\n11\n55\n22\n\nNo. of elements in linked list = 4\n\\*/\n')))}c.isMDXComponent=!0}}]);