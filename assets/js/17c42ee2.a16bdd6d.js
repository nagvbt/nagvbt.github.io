"use strict";(self.webpackChunknagvbt=self.webpackChunknagvbt||[]).push([[38427],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>C});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(t),h=a,C=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return t?r.createElement(C,l(l({ref:n},p),{},{components:t})):r.createElement(C,l({ref:n},p))}));function C(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=h;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[u]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<o;c++)l[c]=t[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1581:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const o={},l="COM Step by Step Tutorial",i={unversionedId:"articles/COM/COM Step by Step Tutorial",id:"articles/COM/COM Step by Step Tutorial",title:"COM Step by Step Tutorial",description:"Creating\xa0comMathServLib which is a COM In-Process DLL for implementing an Simple Addition (Add) and\xa0Subtraction (Sub) functions by writing IMath interface . Finally a console application 'comClient' will consumes the\xa0comMathServLib.",source:"@site/docs/articles/COM/COM Step by Step Tutorial.md",sourceDirName:"articles/COM",slug:"/articles/COM/COM Step by Step Tutorial",permalink:"/docs/articles/COM/COM Step by Step Tutorial",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CPM Basics",permalink:"/docs/articles/COM/COM Basics"},next:{title:"ATL, ActiveX FAQ",permalink:"/docs/articles/COM/atl-faq"}},s={},c=[{value:"Steps for adding required files and writing code",id:"steps-for-adding-required-files-and-writing-code",level:2}],p={toc:c},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"com-step-by-step-tutorial"},"COM Step by Step Tutorial"),(0,a.kt)("p",null,"Creating\xa0",(0,a.kt)("strong",{parentName:"p"},"comMathServLib")," which is a COM In-Process DLL for implementing an Simple Addition (Add) and\xa0Subtraction (Sub) functions by writing IMath interface . Finally a console application '",(0,a.kt)("strong",{parentName:"p"},"comClient"),"' will consumes the\xa0comMathServLib."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"Conventions:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"**uuidof(CMathComp) = classID or CLSID  \n**uuidof(IMath) = InterfaceID or IID  \n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"To get an Interface pointer to IMath call CoCreateInstance(...)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"IMath* pIMath;  \nHRESULT hr = CoCreateInstance ( **uuidof(CMathComp), NULL, CLSCTX_INPROC_SERVER,  \n**uuidof(IMath), (void**) &pIMath );  \n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"CoCreateInstance calls CoGetClassObject(...)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"CoGetClassObject( **uuidof(CMathComp), CLSCTX_INPROC_SERVER, NULL,** uuidof(IMath),  \n(void**) &pIMath);  \n")),(0,a.kt)("p",null,"CoGetClassObject invokes the COM Service Control Manager, which searches in the Registry using the classID. It finds the associated ComServer DLL, loads it into memory, and calls the DllGetClassObject method of the DLL."),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"The DLL contains an object of CMathCompClassFactory. The DllGetClassObject gets the IClassFactory pointer and COM calls CreateInstance(...)")),(0,a.kt)("p",null,"CreateInstance(...) method creates the CMathComp and returns the Pointer to IMath as requested by CoCreateInstance"),(0,a.kt)("p",null,"Steps for creating \xa0",(0,a.kt)("strong",{parentName:"p"},"comMathServLib")," Project: "),(0,a.kt)("p",null,"A. Open Visual Studio 2008",(0,a.kt)("br",{parentName:"p"}),"\n","B. Go to File -> New Project : In the new project dialog under 'Visual C++' select Win32 - Right side select the Win32 Project Template and give the project name as 'comMathServLib'",(0,a.kt)("br",{parentName:"p"}),"\n","C. Win32 Application Wizard Dilog pops up",(0,a.kt)("br",{parentName:"p"}),"\n","-> Click Next",(0,a.kt)("br",{parentName:"p"}),"\n","->In Application Setting -> Application type: Select DLL and click Finish"),(0,a.kt)("h2",{id:"steps-for-adding-required-files-and-writing-code"},"Steps for adding required files and writing code"),(0,a.kt)("p",null,"File can be added by Right click on the Project in 'Solution Explorer' -> Add -> New Item..."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"1. Add a Header File ","[IMath.h]"," to declare the Interface for our Math Component class ",(0,a.kt)("em",{parentName:"strong"},"CMathComp"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"IMath.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'\n# include "Unknwn.h"\n\ninterface IMath : IUnknown  \n{  \n//Simple Math Functions  \nvirtual int **stdcall Add(int i, int j) = 0;  \nvirtual int** stdcall Sub(int i, int j) = 0;  \n};  \n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"2.\xa0Add a C++ File ","[MathComp.cpp]"," to Implement the IMath Interface and also to implement the IUnkown Interface methods")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"MathComp.cpp")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'\n# include "stdafx.h"\n# include "IMath.h"\n# include "MathCompGuidDef.h"\n\nclass CMathComp : public IMath  \n{\npublic:  \nCMathComp()  \n{  \nm_uRefCount = 0;  \ng_uDllLockCount++;  \n}\n\nvirtual ~CMathComp()\n{\n    g_uDllLockCount--;\n}\n\n// IUnknown methods\nvirtual ULONG __stdcall AddRef()\n{\n    m_uRefCount = m_uRefCount+1;  // Increment this object\'s reference count.\n    return m_uRefCount;\n}\n\nvirtual ULONG __stdcall Release()\n{\n    ULONG uRet = m_uRefCount-1;   // Decrement this object\'s reference count.\n\n    if ( 0 == m_uRefCount )       // Releasing last reference?\n    {\n        delete this;\n    }\n\n    return uRet;\n}\n\nvirtual HRESULT __stdcall QueryInterface( REFIID riid, void** ppv )\n{\n    HRESULT hrRet = S_OK;\n\n    // Check that ppv really points to a void*.\n    if ( IsBadWritePtr ( ppv, sizeof(void*) ))\n    {\n        return E_POINTER;\n    }\n\n    // Standard QI initialization - set *ppv to NULL.\n    *ppv = NULL;\n\n    // If the client is requesting an interface we support, set *ppv.\n    if ( InlineIsEqualGUID ( riid, IID_IUnknown ))\n    {\n        *ppv = (IUnknown*) this;\n    }\n    else if ( InlineIsEqualGUID ( riid, __uuidof(IMath) ))\n    {\n        *ppv = (IMath*) this;\n    }\n    else\n    {\n        hrRet = E_NOINTERFACE;\n    }\n\n    // If we\'re returning an interface pointer, AddRef() it.\n    if ( S_OK == hrRet )\n    {\n        ((IUnknown*) *ppv)->AddRef();\n    }\n\n    return hrRet;\n}\n\n//IMath Implementation\nvirtual int __stdcall Add(int i, int j)\n{\n    return i+j;\n}\n\nvirtual int __stdcall Sub(int i, int j)\n{\n    return i-j;\n}\n\nprotected:  \nUINT m_uRefCount; // object\'s reference count  \n};  \n')),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Add a Header File ","[MathCompGuidDef.h]"," for assigning GUIDS for IMath and CMathComp")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"MathCompGuidDef.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'struct **declspec(uuid("{4024093A-F7C4-4ecf-8E60-B79C5AEAE6E0}")) IMath;  \nclass** declspec(uuid("{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}")) CMathComp;  \n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"3. Add a C++ File ","[CMathCompClassFactory.h]"," to Implement the IClassFactory Interface for our Math Component")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"CMathCompClassFactory.h")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\n# include \"stdafx.h\"\n# include \"MathComp.cpp\"\nclass CMathCompClassFactory : public IClassFactory  \n{  \npublic:  \nCMathCompClassFactory()  \n{  \nm_uRefCount = 0;  \ng_uDllLockCount++;\n}\nvirtual ~CMathCompClassFactory()\n{\n    g_uDllLockCount--;\n}\n\n// IUnknown methods\nvirtual ULONG __stdcall AddRef()\n{\n    m_uRefCount = m_uRefCount+1;  // Increment this object's reference count.\n    return m_uRefCount;\n}\n\nvirtual ULONG __stdcall Release()\n{\n    ULONG uRet = m_uRefCount-1;   // Decrement this object's reference count.\n\n    if ( 0 == m_uRefCount )       // Releasing last reference?\n    {\n        delete this;\n    }\n\n    return uRet;\n}\n\nvirtual HRESULT __stdcall QueryInterface( REFIID riid, void** ppv )\n{\n    HRESULT hrRet = S_OK;\n\n    // Check that ppv really points to a void*.\n    if ( IsBadWritePtr ( ppv, sizeof(void*) ))\n    {\n        return E_POINTER;\n    }\n\n    // Standard QI initialization - set *ppv to NULL.\n    *ppv = NULL;\n\n    // If the client is requesting an interface we support, set *ppv.\n    if ( InlineIsEqualGUID ( riid, IID_IUnknown ))\n    {\n        *ppv = (IUnknown*) this;\n    }\n    else if ( InlineIsEqualGUID ( riid, IID_IClassFactory ))\n    {\n        *ppv = (IClassFactory*) this;\n    }\n    else\n    {\n        hrRet = E_NOINTERFACE;\n    }\n\n    // If we're returning an interface pointer, AddRef() it.\n    if ( S_OK == hrRet )\n    {\n        ((IUnknown*) *ppv)->AddRef();\n    }\n\n    return hrRet;\n\n}\n\n// IClassFactory\nvirtual HRESULT __stdcall CreateInstance ( IUnknown* pUnkOuter,  \nREFIID riid,  \nvoid** ppv )  \n{  \nHRESULT hrRet;\n\n\n    // No support aggregation, so pUnkOuter must be NULL.\n    if ( NULL != pUnkOuter )\n    {\n        return CLASS_E_NOAGGREGATION;\n    }\n\n    // Check that ppv really points to a void*.\n    if ( IsBadWritePtr ( ppv, sizeof(void*) ))\n    {\n        return E_POINTER;\n    }\n\n    *ppv = NULL;\n\n    // Create a new COM object!\n    m_pMathServ = new CMathComp();\n\n    if ( NULL == m_pMathServ )\n    {\n        return E_OUTOFMEMORY;\n    }\n\n    // QueryInterface the object for the interface the client is requesting.\n    hrRet = m_pMathServ->QueryInterface ( riid, ppv );\n\n    // If the QI failed, delete the COM object since the client isn't able\n    // to use it (the client doesn't have any interface pointers on the object)\n    if ( FAILED(hrRet) )\n    {\n        delete m_pMathServ;\n    }\n\n    return hrRet;\n}\n\nvirtual HRESULT __stdcall LockServer ( BOOL fLock )\n{\n    // Increase/decrease the DLL ref count, according to the fLock param.\n    fLock ? g_uDllLockCount++ : g_uDllLockCount--;\n    return S_OK;\n}\n\n\nprotected:  \nULONG m_uRefCount;  \nCMathComp* m_pMathServ;  \n};\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"4. Add a C++ File ","[Infrastructure.cpp]"," and add the Infrastructure methods to our comMathServLib In-Process COM Component")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'# include "stdafx.h"\n# include "MathCompGuidDef.h"\n# include "MathCompClassFactory.cpp"\n\nHINSTANCE g_hinstThisDll = NULL; // DLL\'s module handle  \nUINT g_uDllLockCount = 0; // # of COM objects in existence\n\n// DllMain() is our DLL\'s entry point. Windows calls this when a process or thread  \n// loads and unloads the DLL.  \nBOOL APIENTRY DllMain ( HINSTANCE hModule,  \nDWORD ul_reason_for_call,  \nLPVOID lpReserved )  \n{  \nswitch ( ul_reason_for_call )  \n{  \n    case DLL_PROCESS_ATTACH:  \n    {  \n      g_hinstThisDll = hModule;\n      // Calling DisableThreadLibraryCalls() prevents DllMain() from\n      // getting called for every thread that attaches/detaches from DLL\n      DisableThreadLibraryCalls ( hModule );\n    }\n    break;\n\n    case DLL_PROCESS_DETACH:\n    {\n    }\n    break;\n}\n\nreturn TRUE;\n}\n\n// DllGetClassObject() is called when COM needs to get a class factory.  \nSTDAPI DllGetClassObject ( REFCLSID rclsid, REFIID riid, void* *ppv )  \n{  \nHRESULT hrRet;  \nCMathCompClassFactory* pFactory;\n\n// Check that the client is asking for the CSimpleMsgBoxImpl factory.\nif ( !InlineIsEqualGUID ( rclsid, __uuidof(CMathComp) ))\n{\n    return CLASS_E_CLASSNOTAVAILABLE;\n}\n\n// Check that ppv really points to a void*.\nif ( IsBadWritePtr ( ppv, sizeof(void*) ))\n{\n    return E_POINTER;\n}\n\n*ppv = NULL;\n\n// Construct a new class factory object.\npFactory = new CMathCompClassFactory;\n\nif ( NULL == pFactory )\n{\n    return E_OUTOFMEMORY;\n}\n\n// AddRef() the factory since we\'re using it.\npFactory->AddRef();\n\n// QueryInterface() the factory for the interface the client wants.\nhrRet = pFactory->QueryInterface ( riid, ppv );\n\n// We\'re done with the factory, so Release() it.\npFactory->Release();\n\nreturn hrRet;\n\n}\n\n// DllCanUnloadNow() is called when COM wants to unload our DLL from memory.  \n// We check our lock count, which will be nonzero if there are any COM  \n// objects still in memory.  \n// Return S_FALSE to prevent the DLL from being unloaded, or S_OK to let it  \n// be unloaded.  \nSTDAPI DllCanUnloadNow()  \n{  \nreturn g_uDllLockCount > 0 ? S_FALSE : S_OK;  \n}\n\n// DllRegisterServer() creates the registy entries that tells COM where our  \n// server is located and its threading model.  \nSTDAPI DllRegisterServer()  \n{  \nHKEY hCLSIDKey = NULL, hInProcSvrKey = NULL;  \nLONG lRet;  \nTCHAR szModulePath [MAX_PATH];  \nTCHAR szClassDescription[] = _T("MathServ class");  \nTCHAR szThreadingModel[] = _T("Apartment");\n\n__try\n{\n    // Create a key under CLSID for our COM server.\n    lRet = RegCreateKeyEx ( HKEY_CLASSES_ROOT,\n            _T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}"), 0, NULL,\n            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE | KEY_CREATE_SUB_KEY,\n            NULL, &hCLSIDKey, NULL );\n\n    if ( ERROR_SUCCESS != lRet )\n    {\n        return HRESULT_FROM_WIN32(lRet);\n    }\n\n    // The default value of the key is a human-readable\n    // description of the coclass.\n    lRet = RegSetValueEx ( hCLSIDKey, NULL, 0, REG_SZ,\n            (const BYTE*)szClassDescription, sizeof(szClassDescription));\n\n    if ( ERROR_SUCCESS != lRet )\n    {\n        return HRESULT_FROM_WIN32(lRet);\n    }\n\n    // Create the InProcServer32 key, which holds info about our coclass.\n    lRet = RegCreateKeyEx ( hCLSIDKey, _T("InProcServer32"), 0, NULL,\n            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE,\n            NULL, &hInProcSvrKey, NULL );\n\n    if ( ERROR_SUCCESS != lRet )\n    {\n        return HRESULT_FROM_WIN32(lRet);\n    }\n\n    // The default value of the InProcServer32 key holds the\n    // full path to our DLL.\n    GetModuleFileName ( g_hinstThisDll, szModulePath, MAX_PATH );\n\n    lRet = RegSetValueEx(hInProcSvrKey, NULL, 0, REG_SZ, (const BYTE*)szModulePath,\n            sizeof(TCHAR) *(lstrlen(szModulePath)+1) );\n\n    if ( ERROR_SUCCESS != lRet )\n    {\n        return HRESULT_FROM_WIN32(lRet);\n    }\n\n    // The ThreadingModel value tells COM how it should handle threads\n    // in our DLL. The concept of apartments is beyond the scope of this\n    // article, but for simple, single-threaded DLLs, use Apartment.\n    lRet = RegSetValueEx ( hInProcSvrKey, _T("ThreadingModel"), 0, REG_SZ,\n        (const BYTE*) szThreadingModel,\n        sizeof(szThreadingModel) );\n\n    if ( ERROR_SUCCESS != lRet )\n    {\n        return HRESULT_FROM_WIN32(lRet);\n    }\n}\n\n__finally\n{\n    if ( NULL != hCLSIDKey )\n    {\n        RegCloseKey ( hCLSIDKey );\n    }\n\n    if ( NULL != hInProcSvrKey )\n    {\n        RegCloseKey ( hInProcSvrKey );\n    }\n}\n\nreturn S_OK;\n\n}\n\n// DllUnregisterServer() deleted the registy entries that DllRegisterServer() created.  \nSTDAPI DllUnregisterServer()  \n{  \n// Delete our registry entries.  \nRegDeleteKey ( HKEY_CLASSES_ROOT,  \n_T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}InProcServer32"));\n\nRegDeleteKey ( HKEY_CLASSES_ROOT,\n _T("CLSID{3429CFBA-BCEA-4b1d-9441-E1E3C26BD8E9}") );\n\nreturn S_OK;\n\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"5. Add a .def ","[MathServ.def]"," to export functions"),(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"MathServ.def")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"EXPORTS  \nDllRegisterServer PRIVATE  \nDllUnregisterServer PRIVATE  \nDllGetClassObject PRIVATE  \nDllCanUnloadNow PRIVATE  \n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"6. In stdafx.h add module lock count and instance for DLL")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\n# pragma once\n# define WIN32_LEAN_AND_MEAN // Exclude rarely-used stuff from Windows headers\n# include <windows.h>\n# include <tchar.h>\n# include <comdef.h>\n\nextern HINSTANCE g_hinstThisDll; // Our DLL's HINSTANCE  \nextern UINT g_uDllLockCount; // The module lock count  \n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Develop a Console Client")," ",(0,a.kt)("strong",{parentName:"p"},"named 'comClient'"),"  ",(0,a.kt)("strong",{parentName:"p"},"for consuming the 'comMathServLib'")," "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"comClient.cpp")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// comClient.cpp : Defines the entry point for the console application.\n# include <comdef.h>\n# include "../comMathServLib/MathCompGuidDef.h"\n# include "../comMathServLib/IMath.h"\nint main()  \n{  \nIMath* pIMath;  \nHRESULT hr;\n\n// 1. Initialize COM Library\nCoInitialize(NULL);\n\n// 2. Call CoCreateInstance to get the IMath interface pointer\nhr = CoCreateInstance ( __uuidof(CMathComp), NULL, CLSCTX_INPROC_SERVER,\n                        __uuidof(IMath), (void**) &pIMath );\n\nif ( FAILED(hr) )\n{\n    return 0;\n}\n\n// 3. Call the interface functions\nint sum = pIMath->Add(1, 3);\nprintf("Sum = %d n", sum);\n\nint sub = pIMath->Sub(4, 3);\nprintf("Sub = %d n", sub);\n\n// 4. Release the interface pointer if you are done\npIMath->Release();\n\n// 5. Un-Initialize COM Library\nCoUninitialize();\nreturn 0;\n\n}  \n')))}d.isMDXComponent=!0}}]);